#' @export
FindSamples <- function(sample_path, suffix = ".txt.gz", use_subdir = FALSE) {
    assertthat::assert_that(dir.exists(sample_path),
        msg = "Given path does not exist")
    
    files_found = list.files(pattern = paste0("\\", suffix, "$"),
        path = normalizePath(sample_path), full.names = TRUE, recursive = TRUE)
    if(length(files_found) > 0) {
      df = data.frame(sample = "", path = files_found)
      if(use_subdir) {
          df$sample = basename(dirname(df$path))
      } else {
          df$sample = sub(suffix,"",basename(df$path))
      }
      return(df)
    } else {
      return(NULL)
    }
}

#' Processes data from IRFinder output
#'
#' @param Experiment: A data frame containing the necessary information. The first column is the base name of the sample files. The second column is the sample name. All subsequent columns are assumed to be experimental conditions / annotation data (e.g. gender, age, treatment response, etc)
#' @param reference_path: THe path to the reference generated by BuildReference()
#' @param output_path: The path to the output generated by data collation.
#' @export
CollateData <- function(Experiment, reference_path, output_path) {
    assertthat::assert_that("data.frame" %in% class(Experiment),
        msg = "Experiment object needs to be a data frame")
    assertthat::assert_that(ncol(Experiment) >= 2,
        msg = "Experiment needs to contain two columns containing (1) sample name and (2) IRFinder output")

    assertthat::assert_that(file.exists(paste(reference_path, "settings.Rds", sep="/")),
        msg = paste(paste(reference_path, "settings.Rds", sep="/"), "does not exist"))


		settings = readRDS(paste(reference_path, "settings.Rds", sep="/"))
		if(settings$ah_genome != "") {
			ah = AnnotationHub::AnnotationHub()
			genome = ah[[settings$ah_genome]]			
		} else {
			genome = Biostrings::readDNAStringSet(
				normalizePath(paste(reference_path, basename(settings$fasta_file), sep="/"))
			)
		}
    
    colnames(Experiment)[1:2] = c("sample", "path")
    # TODO: check each file within Experiment$path is valid
    
    # Create a subdirectory for each sample within output_path
    base_output_path = normalizePath(dirname(output_path))      # TODO check if this fails
    norm_output_path = paste(base_output_path, basename(output_path), sep="/")
    if(!dir.exists(norm_output_path)) {
        dir.create(norm_output_path)
    }
    
    df.internal = Experiment[,1:2]
    df.internal$paired = FALSE
    df.internal$strand = 0
    df.internal$depth = 0

    for(i in 1:nrow(df.internal)) {
        message(paste("Processing stats of file ", i))
        stats = suppressWarnings(fread(df.internal$path[i], skip = "BAM"))
        stats$Value = as.numeric(stats$Value)
        if(stats$Value[3] == 0 & stats$Value[4] > 0) {
            df.internal$paired[i] = TRUE
            df.internal$depth[i] = stats$Value[4]
        } else if(stats$Value[3] > 0 && stats$Value[4] / stats$Value[3] / 1000) {
            df.internal$paired[i] = TRUE
            df.internal$depth[i] = stats$Value[4]
        } else {
            df.internal$paired[i] = FALSE
            df.internal$depth[i] = stats$Value[3]
        }
        direct = suppressWarnings(fread(df.internal$path[i], skip = "Directionality"))
        direct$Value = as.numeric(direct$Value)
        df.internal$strand[i] = direct$Value[9]
    }
    gc()
    
    if(any(df.internal$strand == 0)) {
        runStranded = FALSE
    } else {
        runStranded = TRUE
    }
    
    # Compile junctions and IR lists first, save to temp files
    for(i in 1:nrow(df.internal)) {
        message(paste("Compiling junction and IR lists from sample: ", i))
        junc = suppressWarnings(as.data.table(fread(df.internal$path[i], skip = "JC_seqname")))
        setnames(junc, "JC_seqname", "seqnames")
        if(!exists("junc.common")) {
            junc.common = junc[,1:4]
        } else {
            junc.common = merge(junc.common, junc[,1:4], all = T)
        }
		# Write temp file
        fst::write.fst(as.data.frame(junc), 
            paste(norm_output_path, paste(Experiment$sample[i], "junc.fst.tmp", sep="."), sep="/"))

        
		# Compile IRFinder based on strand
		if(!runStranded) {
            irf = suppressWarnings(as.data.table(fread(Experiment$path[i], skip = "Nondir_")))
            setnames(irf, c("Nondir_Chr", "Start", "End", "Strand"), c("seqnames","start","end", "strand"))
            if(!exists("irf.common")) {
                irf.common = irf[,1:6]
            } else {
                irf.common = semi_join.DT(irf.common, irf[,1:6], by = colnames(irf.common))
            }
		} else {
            irf = suppressWarnings(as.data.table(fread(Experiment$path[i], skip = "Dir_Chr")))
            setnames(irf, c("Dir_Chr", "Start", "End", "Strand"), c("seqnames","start","end", "strand"))
            if(!exists("irf.common")) {
                irf.common = irf[,1:6]
            } else {
                irf.common = semi_join.DT(irf.common, irf[,1:6], by = colnames(irf.common))
            }
		}
        fst::write.fst(as.data.frame(irf), 
            paste(norm_output_path, paste(Experiment$sample[i], "irf.fst.tmp", sep="."), sep="/"))
    }

    irf.common[, start := start + 1]
    junc.common[, start := start + 1]

    junc.common[strand == ".", strand := "*"]
    left.gr = GRanges(seqnames = junc.common$seqnames, 
        ranges = IRanges(start = junc.common$start, end = junc.common$start + 1), strand = "+")
    right.gr = GRanges(seqnames = junc.common$seqnames, 
        ranges = IRanges(start = junc.common$end - 1, end = junc.common$end), strand = "+")
        
    left.seq = BSgenome::getSeq(genome, left.gr)
    right.seq = BSgenome::getSeq(genome, right.gr)

    junc.common$motif_pos = paste0(as.character(left.seq), as.character(right.seq))
    junc.common$motif_infer_strand = "n"
    junc.common[ motif_pos %in% c("GTAG", "GCAG", "ATAC", "ATAG"), motif_infer_strand := "+"]
    junc.common[ motif_pos %in% c("CTAC", "CTGC", "GTAT", "CTAT"), motif_infer_strand := "-"]
    junc.common[ motif_pos %in% c("GTAC"), motif_infer_strand := "n"]       # Do not accept un-annotated GTACs - too confusing
    # Exclude non-splice motifs (that are also not annotated - i.e. strand == "*")
    junc.common = junc.common[motif_infer_strand != "n" | strand != "*"]

    # Use motif_infer_strand
    junc.common = junc.common[motif_infer_strand == "n", motif_infer_strand := strand]
    junc.common$strand = NULL
    setnames(junc.common, "motif_infer_strand", "strand")


    # Should splicing across gene groups be allowed? Exclude
    Genes = GenomicRanges::makeGRangesFromDataFrame(
        fst::read.fst(paste(reference_path, "fst", "Genes.fst", sep="/"))
    )

    # Exclude distant splice events:

    # Genes.Group.stranded = as.data.table(
        # GenomicRanges::reduce(c(Genes, GenomicRanges::flank(Genes, 5000),
        # GenomicRanges::flank(Genes, 5000, start = FALSE))
    # ))
    # setorder(Genes.Group.stranded, seqnames, start, strand)
    # Genes.Group.stranded[, gene_group_stranded := .I]
    
    # junc.common.left = copy(junc.common)
    # junc.common.left[, start := start - 1]
    # junc.common.left[, end := start + 1]
    # OL = suppressWarnings(
        # GenomicRanges::findOverlaps(
            # GenomicRanges::makeGRangesFromDataFrame(as.data.frame(junc.common.left)), 
            # GenomicRanges::makeGRangesFromDataFrame(as.data.frame(Genes.Group.stranded))
        # )
    # )
    # junc.common$gene_group_left[OL@from] = Genes.Group.stranded$gene_group_stranded[OL@to]

    # junc.common.right = copy(junc.common)
    # junc.common.right[, end := end + 1]
    # junc.common.right[, start := end - 1]
    # OL = suppressWarnings(
        # GenomicRanges::findOverlaps(
            # GenomicRanges::makeGRangesFromDataFrame(as.data.frame(junc.common.right)), 
            # GenomicRanges::makeGRangesFromDataFrame(as.data.frame(Genes.Group.stranded))
        # )
    # )
    # junc.common$gene_group_right[OL@from] = Genes.Group.stranded$gene_group_stranded[OL@to]
        

    # junc.common = junc.common[gene_group_left == gene_group_right & !is.na(gene_group_left)]
    # junc.common$gene_group_left = NULL
    # junc.common$gene_group_right = NULL
    
    # Assign region names to junctions:
    junc.common[, Event := paste0(seqnames, ":", start, "-", end, "/", strand)]
    
    # Annotate junctions
    candidate.introns = as.data.table(fst::read.fst(paste(reference_path, "fst", "junctions.fst", sep="/")))
    candidate.introns[, transcript_biotype_2 := transcript_biotype]
    candidate.introns[!(transcript_biotype %in% c("protein_coding", "processed_transcript",
        "lincRNA", "antisense", "nonsense_mediated_decay")), transcript_biotype_2 := "other"]

    candidate.introns[, transcript_biotype_2 := factor(transcript_biotype_2, c("protein_coding", "processed_transcript",
        "lincRNA", "antisense", "other", "nonsense_mediated_decay"), ordered = TRUE)]
        
    if("transcript_support_level" %in% colnames(candidate.introns)) {
        setorder(candidate.introns, transcript_biotype_2, transcript_support_level)
    } else {
        setorder(candidate.introns, transcript_biotype_2)    
    }
    introns.unique = unique(candidate.introns, by = c("seqnames", "start", "end", "width", "strand"))
    setorder(introns.unique, seqnames, start, end, strand)

    junc.annotation = introns.unique[junc.common, 
        c("seqnames", "start", "end", "strand", "transcript_id", "intron_number", "gene_name", "gene_id", "transcript_biotype"),
        on = c("seqnames", "start", "end", "strand")]
    
    # Use Exon Groups file to designate exon groups to all junctions
    Exon.Groups = GenomicRanges::makeGRangesFromDataFrame(
        fst::read.fst(paste(reference_path, "fst", "Exons.groups.fst", sep="/")),
        keep.extra.columns = TRUE)
    
    # Always calculate stranded for junctions
    # if(!runStranded) {
        # Exon.Groups = Exon.Groups[strand(Exon.Groups) == "*"]
    # } else {
        # Exon.Groups = Exon.Groups[strand(Exon.Groups) != "*"]    
    # }
    Exon.Groups.S = Exon.Groups[strand(Exon.Groups) != "*"]    
    
    junc.common.left = copy(junc.common)
    junc.common.left[, start := start - 1]
    junc.common.left[, end := start + 1]
    OL = suppressWarnings(
        GenomicRanges::findOverlaps(
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(junc.common.left)), 
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(Exon.Groups.S))
        )
    )
    junc.common$gene_group_left[OL@from] = Exon.Groups.S$gene_group[OL@to]
    junc.common$exon_group_left[OL@from] = Exon.Groups.S$exon_group[OL@to]

    junc.common.right = copy(junc.common)
    junc.common.right[, end := end + 1]
    junc.common.right[, start := end - 1]
    OL = suppressWarnings(
        GenomicRanges::findOverlaps(
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(junc.common.right)), 
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(Exon.Groups.S))
        )
    )
    junc.common$gene_group_right[OL@from] = Exon.Groups.S$gene_group[OL@to]
    junc.common$exon_group_right[OL@from] = Exon.Groups.S$exon_group[OL@to]
    
    junc.common[, JG_up := ""]
    junc.common[, JG_down := ""]
    junc.common[strand == "+" & !is.na(gene_group_left) & !is.na(exon_group_left), 
        JG_up := paste(gene_group_left, exon_group_left, sep="_")]
    junc.common[strand == "-" & !is.na(gene_group_right) & !is.na(exon_group_right), 
        JG_up := paste(gene_group_right, exon_group_right, sep="_")]
    junc.common[strand == "+" & !is.na(gene_group_right) & !is.na(exon_group_right), 
        JG_down := paste(gene_group_right, exon_group_right, sep="_")]
    junc.common[strand == "-" & !is.na(gene_group_left) & !is.na(exon_group_left), 
        JG_down := paste(gene_group_left, exon_group_left, sep="_")]

    junc.common$gene_group_left = NULL
    junc.common$gene_group_right = NULL
    junc.common$exon_group_left = NULL
    junc.common$exon_group_right = NULL
    
    irf.common.left = copy(irf.common)
    irf.common.left[, start := start - 1]
    irf.common.left[, end := start + 1]
    OL = suppressWarnings(
        GenomicRanges::findOverlaps(
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(irf.common.left)), 
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(Exon.Groups.S))
        )
    )
    irf.common$gene_group_left[OL@from] = Exon.Groups.S$gene_group[OL@to]
    irf.common$exon_group_left[OL@from] = Exon.Groups.S$exon_group[OL@to]

    irf.common.right = copy(irf.common)
    irf.common.right[, end := end + 1]
    irf.common.right[, start := end - 1]
    OL = suppressWarnings(
        GenomicRanges::findOverlaps(
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(irf.common.right)), 
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(Exon.Groups.S))
        )
    )
    irf.common$gene_group_right[OL@from] = Exon.Groups.S$gene_group[OL@to]
    irf.common$exon_group_right[OL@from] = Exon.Groups.S$exon_group[OL@to]
    
    irf.common[, JG_up := ""]
    irf.common[, JG_down := ""]
    irf.common[strand == "+" & !is.na(gene_group_left) & !is.na(exon_group_left), 
        JG_up := paste(gene_group_left, exon_group_left, sep="_")]
    irf.common[strand == "-" & !is.na(gene_group_right) & !is.na(exon_group_right), 
        JG_up := paste(gene_group_right, exon_group_right, sep="_")]
    irf.common[strand == "+" & !is.na(gene_group_right) & !is.na(exon_group_right), 
        JG_down := paste(gene_group_right, exon_group_right, sep="_")]
    irf.common[strand == "-" & !is.na(gene_group_left) & !is.na(exon_group_left), 
        JG_down := paste(gene_group_left, exon_group_left, sep="_")]

    irf.common$gene_group_left = NULL
    irf.common$gene_group_right = NULL
    irf.common$exon_group_left = NULL
    irf.common$exon_group_right = NULL
    
    if(!runStranded) {
        Exon.Groups = Exon.Groups[strand(Exon.Groups) == "*"]
    } else {
        Exon.Groups = Exon.Groups[strand(Exon.Groups) != "*"]    
    }
    irf.common.left = copy(irf.common)
    irf.common.left[, start := start - 1]
    irf.common.left[, end := start + 1]
    OL = suppressWarnings(
        GenomicRanges::findOverlaps(
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(irf.common.left)), 
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(Exon.Groups.S))
        )
    )
    irf.common$gene_group_left[OL@from] = Exon.Groups.S$gene_group[OL@to]
    irf.common$exon_group_left[OL@from] = Exon.Groups.S$exon_group[OL@to]

    irf.common.right = copy(irf.common)
    irf.common.right[, end := end + 1]
    irf.common.right[, start := end - 1]
    OL = suppressWarnings(
        GenomicRanges::findOverlaps(
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(irf.common.right)), 
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(Exon.Groups.S))
        )
    )
    irf.common$gene_group_right[OL@from] = Exon.Groups.S$gene_group[OL@to]
    irf.common$exon_group_right[OL@from] = Exon.Groups.S$exon_group[OL@to]
    
    irf.common[, IRG_up := ""]
    irf.common[, IRG_down := ""]
    irf.common[strand == "+" & !is.na(gene_group_left) & !is.na(exon_group_left), 
        IRG_up := paste(gene_group_left, exon_group_left, sep="_")]
    irf.common[strand == "-" & !is.na(gene_group_right) & !is.na(exon_group_right), 
        IRG_up := paste(gene_group_right, exon_group_right, sep="_")]
    irf.common[strand == "+" & !is.na(gene_group_right) & !is.na(exon_group_right), 
        IRG_down := paste(gene_group_right, exon_group_right, sep="_")]
    irf.common[strand == "-" & !is.na(gene_group_left) & !is.na(exon_group_left), 
        IRG_down := paste(gene_group_left, exon_group_left, sep="_")]
    irf.common$gene_group_left = NULL
    irf.common$gene_group_right = NULL
    irf.common$exon_group_left = NULL
    irf.common$exon_group_right = NULL

    irf.common[, EventRegion := paste0(seqnames, ":", start, "-", end, "/", strand)]

    Splice.Anno = as.data.table(fst::read.fst(paste(reference_path, "fst", "Splice.fst", sep="/")))
    candidate.introns[, Event1a := Event]
    candidate.introns[, Event2a := Event]
    Splice.Anno[candidate.introns, on = "Event1a", up_1a := paste(i.gene_group_stranded, 
        i.exon_group_stranded_upstream, sep="_")]
    Splice.Anno[candidate.introns, on = "Event1a", down_1a := paste(i.gene_group_stranded, 
        i.exon_group_stranded_downstream, sep="_")]
    Splice.Anno[candidate.introns, on = "Event2a", down_2a := paste(i.gene_group_stranded, 
        i.exon_group_stranded_downstream, sep="_")]
    
    Splice.Anno[EventType %in% c("MXE", "SE", "ALE", "A3SS"),
        JG_up := up_1a]
    Splice.Anno[EventType %in% c("SE", "AFE", "A5SS"),
        JG_down := down_1a]
    Splice.Anno[EventType %in% c("MXE"),
        JG_down := down_2a]
    
    Splice.Anno$up_1a = NULL
    Splice.Anno$down_1a = NULL
    Splice.Anno$down_2a = NULL
    Splice.Anno[, strand := tstrsplit(Event1a, split="/")[[2]]]
    
    rm(candidate.introns, introns.unique)
    gc()

    for(i in seq_len(nrow(df.internal))) {
        message(paste("Processing data for sample: ", i))
        junc = as.data.table(
            fst::read.fst(paste(norm_output_path, paste(Experiment$sample[i], "junc.fst.tmp", sep="."), sep="/"))
        )
        # setnames(junc, "JC_seqname", "seqnames")
        junc[, start := start + 1]
        junc$strand = NULL

        junc = junc[junc.common, on = colnames(junc.common)[1:3]]
        
        if(df.internal$strand[i] == 0) {
            junc$count = junc$total    
        } else if(df.internal$strand[i] == -1) {
            junc$count = 0
            junc[strand == "+", count := neg]
            junc[strand == "-", count := pos]
            junc[strand == "*", count := total]
        } else {
            junc$count = 0
            junc[strand == "+", count := pos]
            junc[strand == "-", count := neg]
            junc[strand == "*", count := total]    
        }
        junc[is.na(count), count := 0]
        junc = junc[,c("seqnames", "start", "end", "strand", "Event", "count")]
        junc = cbind(junc, junc.common[, c("JG_up", "JG_down")])
        junc[, SO_L := 0]
        junc[, SO_R := 0]
        junc[JG_up != "" & strand == "+", SO_L := sum(count), by = "JG_up"]
        junc[JG_down != "" & strand == "+", SO_R := sum(count), by = "JG_down"]
        junc[JG_up != "" & strand == "-", SO_R := sum(count), by = "JG_up"]
        junc[JG_down != "" & strand == "-", SO_L := sum(count), by = "JG_down"]
        
        fst::write.fst(as.data.frame(junc), 
            paste(norm_output_path, paste(Experiment$sample[i], "junc.fst", sep="."), sep="/"))
        
        splice = copy(Splice.Anno)
        
        splice[, count_Event1a := 0]
        splice[!is.na(Event1a), count_Event1a := junc$count[match(Event1a, junc$Event)]]
        splice[is.na(count_Event1a), count_Event1a := 0]
        splice[, count_Event2a := 0]
        splice[!is.na(Event2a), count_Event2a := junc$count[match(Event2a, junc$Event)]]
        splice[is.na(count_Event2a), count_Event2a := 0]
        splice[, count_Event1b := 0]
        splice[!is.na(Event1b), count_Event1b := junc$count[match(Event1b, junc$Event)]]
        splice[is.na(count_Event1b), count_Event1b := 0]
        splice[, count_Event2b := 0]
        splice[!is.na(Event2b), count_Event2b := junc$count[match(Event2b, junc$Event)]]
        splice[is.na(count_Event2b), count_Event2b := 0]

        splice[, count_JG_up := 0]
        splice[!is.na(JG_up) & strand == "+", count_JG_up := junc$SO_L[match(JG_up, junc$JG_up)]]
        splice[!is.na(JG_up) & strand == "-", count_JG_up := junc$SO_R[match(JG_up, junc$JG_up)]]
        splice[is.na(count_JG_up), count_JG_up := 0]
        splice[, count_JG_down := 0]
        splice[!is.na(JG_down) & strand == "-", count_JG_down := junc$SO_L[match(JG_down, junc$JG_down)]]
        splice[!is.na(JG_down) & strand == "+", count_JG_down := junc$SO_R[match(JG_down, junc$JG_down)]]
        splice[is.na(count_JG_down), count_JG_down := 0]

        # Splice participation: sum of two events compared to JG_up / JG_down
        splice[, partic_up := 0]
        splice[, partic_down := 0]

        splice[EventType %in% c("MXE", "SE", "ALE", "A3SS"), partic_up := count_Event1a + count_Event1b]
        splice[EventType %in% c("MXE"), partic_down := count_Event2a + count_Event2b]
        splice[EventType %in% c("SE"), partic_down := count_Event2a + count_Event1b]
        splice[EventType %in% c("AFE", "A5SS"), partic_down := count_Event1a + count_Event1b]

        # Splice coverage = participation / max_JG
        
        splice[, cov_up := 0]
        splice[count_JG_up > 0, cov_up := partic_up / count_JG_up]
        splice[, cov_down := 0]
        splice[count_JG_down > 0, cov_down := partic_down / count_JG_down]
        splice[EventType %in% c("MXE", "SE") & cov_up < cov_down, coverage := cov_up]
        splice[EventType %in% c("MXE", "SE") & cov_up >= cov_down, coverage := cov_down]
        splice[EventType %in% c("ALE", "A3SS"), coverage := cov_up]
        splice[EventType %in% c("AFE", "A5SS"), coverage := cov_down]
        
        irf = as.data.table(
            fst::read.fst(paste(norm_output_path, paste(Experiment$sample[i], "irf.fst.tmp", sep="."), sep="/"))
        )
        irf[, start := start + 1]
        irf = irf[irf.common, on = colnames(irf.common)[1:6], EventRegion := i.EventRegion]
        
        # Extra statistics:
        irf[, SpliceMax := 0]
        irf[SpliceLeft >= SpliceRight, SpliceMax := SpliceLeft]
        irf[SpliceLeft < SpliceRight, SpliceMax := SpliceRight]

        irf[junc, on = c("seqnames", "start", "end", "strand"), SpliceOverLeft := SO_L]
        irf[junc, on = c("seqnames", "start", "end", "strand"), SpliceOverRight := SO_R]
        irf[SpliceOverLeft >= SpliceOverRight, SpliceOverMax := SpliceOverLeft]
        irf[SpliceOverLeft < SpliceOverRight, SpliceOverMax := SpliceOverRight]
        
        irf[, IROratio := 0]
        irf[IntronDepth < 1 & IntronDepth > 0 & (Coverage + SpliceOverMax) > 0, IROratio := Coverage / (Coverage + SpliceOverMax)]
        irf[IntronDepth >= 1, IROratio := IntronDepth / (IntronDepth + SpliceOverMax)]

        irf[, TotalDepth := IntronDepth + SpliceOverMax]

        splice.no_region = splice[!(EventRegion %in% irf$EventRegion)]
        splice.no_region[, Depth1a := irf$TotalDepth[match(Event1a, irf$EventRegion)]]
        splice.no_region[, Depth2a := irf$TotalDepth[match(Event2a, irf$EventRegion)]]
        splice.no_region[, Depth1b := irf$TotalDepth[match(Event1b, irf$EventRegion)]]
        splice.no_region[, Depth2b := irf$TotalDepth[match(Event2b, irf$EventRegion)]]
        splice.no_region[, Depth := 0]
        splice.no_region[count_JG_up > count_JG_down, Depth := count_JG_up]
        splice.no_region[count_JG_up <= count_JG_down, Depth := count_JG_down]
        splice.no_region[is.na(Depth1a), Depth1a := 0]
        splice.no_region[is.na(Depth1b), Depth1b := 0]
        splice.no_region[is.na(Depth2a), Depth2a := 0]
        splice.no_region[is.na(Depth2b), Depth2b := 0]
        splice.no_region[Depth1a > Depth2a, DepthA := Depth1a]
        splice.no_region[Depth1b > Depth2b, DepthB := Depth1b]
        splice.no_region[Depth1a <= Depth2a, DepthA := Depth2a]
        splice.no_region[Depth1b <= Depth2b, DepthB := Depth2b]
        splice.no_region[DepthA > DepthB, Depth := DepthA]
        splice.no_region[DepthA <= DepthB, Depth := DepthB]

        splice[, TotalDepth := 0]
        splice[irf, on = "EventRegion", TotalDepth := i.TotalDepth]
        splice[splice.no_region, on = "EventName", TotalDepth := i.Depth]

        fst::write.fst(as.data.frame(splice), 
            paste(norm_output_path, paste(Experiment$sample[i], "splice.fst", sep="."), sep="/"))
        
        fst::write.fst(as.data.frame(irf),
            paste(norm_output_path, paste(Experiment$sample[i], "irf.fst", sep="."), sep="/"))
            
        file.remove(paste(norm_output_path, paste(Experiment$sample[i], "junc.fst.tmp", sep="."), sep="/"))
        file.remove(paste(norm_output_path, paste(Experiment$sample[i], "irf.fst.tmp", sep="."), sep="/"))
    }
    message("NxtIRF FST files generated")
}

#' @export
BuildFilterData = function(irf_fst_files, colData) {
	# Builds all necessary data from fst files in order to decide which events will be filtered by data filters
		
	assertthat::assert_that(all(grepl("\\.irf.fst$", irf_fst_files)),
		msg = "irf_fst_files must end in '.irf.fst'")
	assertthat::assert_that(all(file.exists(irf_fst_files)),
		msg = "Some IRFinder fst files do not exist")
	
  df = data.frame(sample = colData[,1], base_name = gsub("\\.irf.fst$", "", irf_fst_files),
    irf_file = irf_fst_files, stringsAsFactors = FALSE)
		
  df$splice_file = paste0(df$base_name, ".splice.fst")
	
	# skinny annotation
	irf.anno.brief = as.data.table(fst::read.fst(df$irf_file[1]))
	setnames(irf.anno.brief, "Name", "EventName")
	irf.anno.brief[, EventType := "IR"]
	irf.anno.brief[, EventRegion := paste0(seqnames, ":", start, "-", end, "/", strand)]
	irf.anno.brief = irf.anno.brief[, c("EventName", "EventType", "EventRegion")]
  splice.anno.brief = as.data.table(fst::read.fst(df$splice_file[1], c("EventName", "EventType", "EventRegion")))
	
	rowEvent = rbind(irf.anno.brief, splice.anno.brief)
			
	rowEvent.Depth = copy(rowEvent)
	rowEvent.Coverage = copy(rowEvent)
  # TODO: Overhang_5p, Overhang_3p

	for(i in seq_len(nrow(df))) {
    irf = as.data.table(fst::read.fst(df$irf_file[i]))
    setnames(irf, "Name", "EventName")
    splice = as.data.table(fst::read.fst(df$splice_file[i]))
    
    rowEvent.Depth[, c(df$sample[i]) := 0]
    rowEvent.Depth[irf, on = "EventName", c(df$sample[i]) := TotalDepth]
    rowEvent.Depth[splice, on = "EventName", c(df$sample[i]) := TotalDepth]
    
    rowEvent.Coverage[, c(df$sample[i]) := 0]
    rowEvent.Coverage[irf, on = "EventName", c(df$sample[i]) := Coverage]
    rowEvent.Coverage[splice, on = "EventName", c(df$sample[i]) := coverage]
	}
  
  rownames(colData) = colData$sample
  rownames(rowData) = rowData$EventName
  colData$sample = NULL
  se = SummarizedExperiment::SummarizedExperiment(assays = SimpleList(
		Depth = rowEvent.Depth[, -1:-2], Coverage = rowEvent.Coverage[,-1:-2],
	), rowData = rowEvent, colData = colData)
  rownames(se) = SummarizedExperiment::rowData(se)$EventName
    
  return(se)

}

#' @export
BuildSE = function(irf_fst_files, colData, IRMode = c("SpliceOverMax", "SpliceMax")) {
	# Builds all PSI-related data
	# Included: matrix for EventA or IR
	# Excluded: matrix for EventB or Splice(Over)Max
	# Up_Inc: upstream included event (IR upstream overhang / MXE / SE)
	# Down_Inc: downstream included event for IR/MXE/SE
	# Up_Exc, Down_Exc: upstream excluded event (i.e. downstream casette exon) for MXE only
		
	assertthat::assert_that(all(grepl("\\.irf.fst$", irf_fst_files)),
		msg = "irf_fst_files must end in '.irf.fst'")
	assertthat::assert_that(all(file.exists(irf_fst_files)),
		msg = "Some IRFinder fst files do not exist")
	IRMode = match.arg(IRMode)
	assertthat::assert_that(IRMode != "",
		msg = "IRMode must be either 'SpliceOverMax' (default) or 'SpliceMax'")
		
  df = data.frame(sample = colData[,1], base_name = gsub("\\.irf.fst$", "", irf_fst_files),
    irf_file = irf_fst_files, stringsAsFactors = FALSE)
  df$splice_file = paste0(df$base_name, ".splice.fst")
	# skinny annotation
	irf.anno.brief = as.data.table(fst::read.fst(df$irf_file[1]))
	setnames(irf.anno.brief, "Name", "EventName")
	irf.anno.brief[, EventType := "IR"]
	irf.anno.brief[, EventRegion := paste0(seqnames, ":", start, "-", end, "/", strand)]
	irf.anno.brief = irf.anno.brief[, c("EventName", "EventType", "EventRegion")]
  splice.anno.brief = as.data.table(fst::read.fst(df$splice_file[1], c("EventName", "EventType", "EventRegion")))
	
	rowEvent = rbind(irf.anno.brief, splice.anno.brief)
			
	rowEvent.Included = copy(rowEvent)
	rowEvent.Excluded = copy(rowEvent)
	
	rowEvent.Up_Inc = rowEvent[EventType %in% c("IR", "MXE", "SE")]
	rowEvent.Down_Inc = rowEvent[EventType %in% c("IR", "MXE", "SE")]
	rowEvent.Up_Exc = rowEvent[EventType %in% c("MXE")]		# for IR and SE, this defaults to rowEvent.Excluded
	rowEvent.Down_Exc = rowEvent[EventType %in% c("MXE")]

	for(i in seq_len(nrow(df))) {
    irf = as.data.table(fst::read.fst(df$irf_file[i]))
    setnames(irf, "Name", "EventName")
    splice = as.data.table(fst::read.fst(df$splice_file[i]))
    
    rowEvent.Included[, c(df$sample[i]) := 0]
    rowEvent.Included[irf, on = "EventName", c(df$sample[i]) := IntronDepth]
    rowEvent.Included[splice[EventType %in% c("SE", "MXE")], 
			on = "EventName", c(df$sample[i]) := (Event1a + Event2a) / 2]
    rowEvent.Included[splice[!(EventType %in% c("SE", "MXE"))], 
			on = "EventName", c(df$sample[i]) := Event1a]
			
    rowEvent.Excluded[, c(df$sample[i]) := 0]
		if(IRMode == "SpliceOverMax") {
			rowEvent.Excluded[irf, on = "EventName", c(df$sample[i]) := SpliceOverMax]		
		} else {
			rowEvent.Excluded[irf, on = "EventName", c(df$sample[i]) := SpliceMax]				
		}
    rowEvent.Excluded[splice[EventType %in% c("MXE")], 
			on = "EventName", c(df$sample[i]) := (Event1b + Event2b) / 2]
    rowEvent.Excluded[splice[!(EventType %in% c("MXE"))], 
			on = "EventName", c(df$sample[i]) := Event1b]
		
		# Validity checking for IR, MXE, SE
    rowEvent.Up_Inc[, c(df$sample[i]) := 0]
    rowEvent.Up_Inc[irf[strand == "+"], on = "EventName", c(df$sample[i]) := ExonToIntronReadsLeft]
    rowEvent.Up_Inc[irf[strand == "-"], on = "EventName", c(df$sample[i]) := ExonToIntronReadsRight]
    rowEvent.Up_Inc[splice, on = "EventName", c(df$sample[i]) := Event1a]

    rowEvent.Down_Inc[, c(df$sample[i]) := 0]
    rowEvent.Down_Inc[irf[strand == "+"], on = "EventName", c(df$sample[i]) := ExonToIntronReadsRight]
    rowEvent.Down_Inc[irf[strand == "-"], on = "EventName", c(df$sample[i]) := ExonToIntronReadsLeft]
    rowEvent.Down_Inc[splice, on = "EventName", c(df$sample[i]) := Event2a]
		
    rowEvent.Up_Exc[splice, on = "EventName", c(df$sample[i]) := Event2a]
		rowEvent.Down_Exc[splice, on = "EventName", c(df$sample[i]) := Event2b]
	}
  
  rownames(colData) = colData$sample
  rownames(rowData) = rowData$EventName
  colData$sample = NULL
  se = SummarizedExperiment::SummarizedExperiment(assays = SimpleList(
		Included = rowEvent.Included[, -1:-2], Excluded = rowEvent.Excluded[,-1:-2],
	), rowData = rowEvent, colData = colData)
  rownames(se) = SummarizedExperiment::rowData(se)$EventName
  
	SummarizedExperiment::metadata(se)$Up_Inc = rowEvent.Up_Inc
	SummarizedExperiment::metadata(se)$Down_Inc = rowEvent.Down_Inc
	SummarizedExperiment::metadata(se)$Up_Exc = rowEvent.Up_Exc
	SummarizedExperiment::metadata(se)$Down_Exc = rowEvent.Down_Exc
	
  return(se)
}





