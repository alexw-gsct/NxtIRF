#' @export
FindSamples <- function(sample_path, suffix = ".txt.gz", use_subdir = FALSE) {
    assertthat::assert_that(dir.exists(sample_path),
        msg = "Given path does not exist")
    
    df = data.frame(sample = "", path = list.files(pattern = paste0("\\", suffix, "$"),
        path = normalizePath(sample_path), full.names = TRUE, recursive = TRUE))
    if(use_subdir) {
        df$sample = basename(dirname(df$path))
    } else {
        df$sample = sub(suffix,"",basename(df$path))
    }
    return(df)
}

#' Processes data from IRFinder output (Step 1: performs gene count and finds unannotated junctions)
#'
#' @param Experiment: A data frame containing the necessary information. The first column is the base name of the sample files. The second column is the sample name. All subsequent columns are assumed to be experimental conditions / annotation data (e.g. gender, age, treatment response, etc)
#' @param reference_path: THe path to the reference generated by BuildReference()
#' @param output_path: The path to the output generated by data collation.
#' @export
CollateData <- function(Experiment, reference_path, ah_genome, output_path) {
    assertthat::assert_that("data.frame" %in% class(Experiment),
        msg = "Experiment object needs to be a data frame")
    assertthat::assert_that(ncol(Experiment) >= 2,
        msg = "Experiment needs to contain two columns containing (1) sample name and (2) IRFinder output")
    
    colnames(Experiment)[1:2] = c("sample", "path")
    
    # Create a subdirectory for each sample within output_path
    base_output_path = normalizePath(dirname(output_path))      # TODO check if this fails
    norm_output_path = paste(base_output_path, basename(output_path), sep="/")
    if(!dir.exists(norm_output_path)) {
        dir.create(norm_output_path)
    }
    for(i in 1:nrow(Experiment)) {
        if(!dir.exists(paste(norm_output_path, Experiment$sample[i], sep="/"))) {
            dir.create(paste(norm_output_path, Experiment$sample[i], sep="/"))
        }
    }
    
    df.internal = Experiment[,1:2]
    df.internal$paired = FALSE
    df.internal$strand = 0
    df.internal$depth = 0

    for(i in 1:nrow(df.internal)) {
        message(paste("Processing stats of file ", i))
        stats = suppressWarnings(fread(df.internal$path[i], skip = "BAM"))
        stats$Value = as.numeric(stats$Value)
        if(stats$Value[3] == 0 & stats$Value[4] > 0) {
            df.internal$paired[i] = TRUE
            df.internal$depth[i] = stats$Value[4]
        } else if(stats$Value[3] > 0 && stats$Value[4] / stats$Value[3] / 1000) {
            df.internal$paired[i] = TRUE
            df.internal$depth[i] = stats$Value[4]
        } else {
            df.internal$paired[i] = FALSE
            df.internal$depth[i] = stats$Value[3]
        }
        direct = suppressWarnings(fread(df.internal$path[i], skip = "Directionality"))
        direct$Value = as.numeric(direct$Value)
        df.internal$strand[i] = direct$Value[9]
    }
    gc()
    
    # Compile junctions first
    for(i in 1:nrow(df.internal)) {
        message(paste("Compiling junction list from sample: ", i))
        junc = suppressWarnings(as.data.table(fread(df.internal$path[i], skip = "JC_seqname")))
        setnames(junc, "JC_seqname", "seqnames")
        if(!exists("junc.common")) {
            junc.common = junc[,1:4]
        } else {
            junc.common = merge(junc.common, junc[,1:4], all = T)
        }
    }
    
#    ah_genome = "AH65745"
    ah = AnnotationHub::AnnotationHub()
    genome = ah[[ah_genome]]

    junc.common[, start := start + 1]
    junc.common[strand == ".", strand := "*"]
    left.gr = GRanges(seqnames = junc.common$seqnames, 
        ranges = IRanges(start = junc.common$start, end = junc.common$start + 1), strand = "+")
    right.gr = GRanges(seqnames = junc.common$seqnames, 
        ranges = IRanges(start = junc.common$end - 1, end = junc.common$end), strand = "+")
        
    left.seq = BSgenome::getSeq(genome, left.gr)
    right.seq = BSgenome::getSeq(genome, right.gr)

    junc.common$motif_pos = paste0(as.character(left.seq), as.character(right.seq))
    junc.common$motif_infer_strand = "n"
    junc.common[ motif_pos %in% c("GTAG", "GCAG", "ATAC", "ATAG"), motif_infer_strand := "+"]
    junc.common[ motif_pos %in% c("CTAC", "CTGC", "GTAT", "CTAT"), motif_infer_strand := "-"]
    junc.common[ motif_pos %in% c("GTAC"), motif_infer_strand := "*"]
    # Exclude non-splice motifs
    junc.common = junc.common[motif_infer_strand != "n"]

    # Use motif_infer_strand
    junc.common$strand = NULL
    setnames(junc.common, "motif_infer_strand", "strand")

    # Should splicing across gene groups be allowed? Exclude
    Genes = GenomicRanges::makeGRangesFromDataFrame(
        fst::read.fst(paste(reference_path, "fst", "Genes.fst", sep="/"))
    )
    Genes.Group.stranded = as.data.table(
        GenomicRanges::reduce(c(Genes, GenomicRanges::flank(Genes, 5000),
        GenomicRanges::flank(Genes, 5000, start = FALSE))
    ))
    setorder(Genes.Group.stranded, seqnames, start, strand)
    Genes.Group.stranded[, gene_group_stranded := .I]
    
    junc.common.left = copy(junc.common)
    junc.common.left[, start := start - 1]
    junc.common.left[, end := start + 1]
    OL = suppressWarnings(
        GenomicRanges::findOverlaps(
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(junc.common.left)), 
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(Genes.Group.stranded))
        )
    )
    junc.common$gene_group_left[OL@from] = Genes.Group.stranded$gene_group_stranded[OL@to]

    junc.common.right = copy(junc.common)
    junc.common.right[, end := end + 1]
    junc.common.right[, start := end - 1]
    OL = suppressWarnings(
        GenomicRanges::findOverlaps(
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(junc.common.right)), 
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(Genes.Group.stranded))
        )
    )
    junc.common$gene_group_right[OL@from] = Genes.Group.stranded$gene_group_stranded[OL@to]
        
    # Quick and dirty annotation of exon group information
    # Exons = GenomicRanges::makeGRangesFromDataFrame(
        # fst::read.fst(paste(reference_path, "fst", "Exons.fst", sep="/")), keep.extra.columns = TRUE
    # )
    # OL = suppressWarnings(
        # GenomicRanges::findOverlaps(
            # GenomicRanges::makeGRangesFromDataFrame(as.data.frame(junc.common.left)), 
            # GenomicRanges::makeGRangesFromDataFrame(as.data.frame(Exons))
        # )
    # )
    # junc.common$exon_group_left = NA
    # junc.common$exon_group_left[OL@from] = Exons$exon_group_stranded[OL@to]
    # OL = suppressWarnings(
        # GenomicRanges::findOverlaps(
            # GenomicRanges::makeGRangesFromDataFrame(as.data.frame(junc.common.right)), 
            # GenomicRanges::makeGRangesFromDataFrame(as.data.frame(Exons))
        # )
    # )
    # junc.common$exon_group_right = NA
    # junc.common$exon_group_right[OL@from] = Exons$exon_group_stranded[OL@to]

    # Exclude distant splice events:
    junc.common = junc.common[gene_group_left == gene_group_right & !is.na(gene_group_left)]
    junc.common$gene_group_left = NULL
    junc.common$gene_group_right = NULL
    
    # Assign region names to junctions:
    junc.common[, Event := paste0(seqnames, ":", start, "-", end, "/", strand)]
    
    # Annotate junctions
    candidate.introns = as.data.table(fst::read.fst(paste(reference_path, "fst", "candidate.introns.fst", sep="/")))
    candidate.introns[, transcript_biotype_2 := transcript_biotype]
    candidate.introns[!(transcript_biotype %in% c("protein_coding", "processed_transcript",
        "lincRNA", "antisense", "nonsense_mediated_decay")), transcript_biotype_2 := "other"]

    candidate.introns[, transcript_biotype_2 := factor(transcript_biotype_2, c("protein_coding", "processed_transcript",
        "lincRNA", "antisense", "other", "nonsense_mediated_decay"), ordered = TRUE)]
        
    if("transcript_support_level" %in% colnames(candidate.introns)) {
        setorder(candidate.introns, transcript_biotype_2, transcript_support_level)
    } else {
        setorder(candidate.introns, transcript_biotype_2)    
    }
    introns.unique = unique(candidate.introns, by = c("seqnames", "start", "end", "width", "strand"))
    setorder(introns.unique, seqnames, start, end, strand)

    junc.annotation = introns.unique[junc.common, 
        c("seqnames", "start", "end", "strand", "transcript_id", "intron_number", "gene_name", "gene_id", "transcript_biotype"),
        on = c("seqnames", "start", "end", "strand")]
        
    rm(candidate.introns, introns.unique)
    gc()
    # obligate.introns.stranded = fst::read.fst(paste(reference_path, "fst", "obligate.introns.stranded.fst", sep="/"))        
    # obligate.introns.unstranded = fst::read.fst(paste(reference_path, "fst", "obligate.introns.unstranded.fst", sep="/"))        

    # OL.stranded = suppressWarnings(GenomicRanges::findOverlaps(
        # makeGRangesFromDataFrame(as.data.frame(obligate.introns.stranded)),
        # makeGRangesFromDataFrame(as.data.frame(junc.common))
        # ))
    # OL.unstranded = suppressWarnings(GenomicRanges::findOverlaps(
        # makeGRangesFromDataFrame(as.data.frame(obligate.introns.unstranded)),
        # makeGRangesFromDataFrame(as.data.frame(junc.common)), 
        # ignore.strand=TRUE))
    
    # remove obligate introns for which there is no overlap with current dataset
    # obligate.introns.stranded = obligate.introns.stranded[unique(OL.stranded@from),]
    # obligate.introns.unstranded = obligate.introns.unstranded[unique(OL.unstranded@from),]

    # OL.stranded = suppressWarnings(GenomicRanges::findOverlaps(
        # makeGRangesFromDataFrame(as.data.frame(obligate.introns.stranded)),
        # makeGRangesFromDataFrame(as.data.frame(junc.common))
        # ))
    # OL.unstranded = suppressWarnings(GenomicRanges::findOverlaps(
        # makeGRangesFromDataFrame(as.data.frame(obligate.introns.unstranded)),
        # makeGRangesFromDataFrame(as.data.frame(junc.common)), 
        # ignore.strand=TRUE))


    for(i in 1:nrow(df.internal)) {
        message(paste("Processing junctions for sample: ", i))
        junc = suppressWarnings(as.data.table(fread(df.internal$path[i], skip = "JC_seqname")))
        setnames(junc, "JC_seqname", "seqnames")
        junc[, start := start + 1]
        junc$strand = NULL

        junc = junc[junc.common, on = colnames(junc.common)[1:3]]
        
        if(df.internal$strand[i] == 0) {
            junc$count = junc$total    
        } else if(df.internal$strand[i] == -1) {
            junc$count = 0
            junc[strand == "+", count := neg]
            junc[strand == "-", count := pos]
            junc[strand == "*", count := total]
        } else {
            junc$count = 0
            junc[strand == "+", count := pos]
            junc[strand == "-", count := neg]
            junc[strand == "*", count := total]    
        }
        junc[is.na(count), count := 0]
        junc = junc[,c("seqnames", "start", "end", "strand", "Event", "count")]
        
        # Calculate SpliceOver here
        # if(df.internal$strand[i] == 0) {
            # junc.OL = data.table(from = OL.unstranded@from, to = OL.unstranded@to)
            # OL = as.data.table(obligate.introns.unstranded)
        # } else {
            # junc.OL = data.table(from = OL.stranded@from, to = OL.stranded@to)
            # OL = as.data.table(obligate.introns.stranded)
        # }

        # OL.expanded = OL[junc.OL$from]
        # OL.expanded[, count := junc$count[junc.OL$to]]
        # OL = OL.expanded[, lapply(.SD, sum, na.rm = TRUE), by = c("seqnames","start","end", "strand")]
        
        # junc.expanded = junc[junc.OL$to]
        # junc.expanded[, SpliceOver := OL$count[junc.OL$from]]
        # junc.SO = junc.expanded[, lapply(.SD, mean, na.rm = TRUE), by = c("seqnames","start","end", "strand", "name")]
        # junc[junc.SO, SpliceOver := i.SpliceOver, on = c("seqnames","start","end", "strand", "name")]
        # junc[is.na(SpliceOver), SpliceOver := 0]

        fst::write.fst(as.data.frame(junc), 
            paste(norm_output_path, Experiment$sample[i], "junc.fst", sep="/"))
    }

    # Semi-join IRFinder annotation
    
    # Target files to generate
    
    # Set of IRFinder coverage files with guaranteed same row order for all samples
    # Unified junction counts for all samples
    # Unified gene counts for all samples

    # Create irf.common containing all rows found
    if(any(df.internal$strand == 0)) {
        for(i in 1:nrow(Experiment)) {
            message(paste("Processing file ", i))
            irf = suppressWarnings(as.data.table(fread(Experiment$path[i], skip = "Nondir_")))
            if(!exists("irf.common")) {
                irf.common = irf[,1:6]
            } else {
                irf.common = semi_join.DT(irf.common, irf[,1:6], by = colnames(irf.common))
            }
        }
        
        # Open each file again and left_merge with irf.common
        for(i in 1:nrow(Experiment)) {
            message(paste("Processing file ", i))
            irf = suppressWarnings(as.data.table(fread(Experiment$path[i], skip = "Nondir_")))
            irf = irf.common[irf, on = colnames(irf.common)[1:6]]
            fst::write.fst(as.data.frame(irf), 
                paste(norm_output_path, Experiment$sample[i], "IR.fst", sep="/")
            )
        }
    } else {
        for(i in 1:nrow(Experiment)) {
            message(paste("Processing file ", i))
            irf = suppressWarnings(as.data.table(fread(Experiment$path[i], skip = "Dir_Chr")))
            if(!exists("irf.common")) {
                irf.common = irf[,1:6]
            } else {
                irf.common = semi_join.DT(irf.common, irf[,1:6], by = colnames(irf.common))
            }
        }
        
        # Open each file again and left_merge with irf.common
        for(i in 1:nrow(Experiment)) {
            message(paste("Processing file ", i))
            irf = suppressWarnings(as.data.table(fread(Experiment$path[i], skip = "Dir_Chr")))
            irf = irf[irf.common, on = colnames(irf.common)[1:6]]
            setnames(irf, c("Dir_Chr", "Start", "End", "Strand"), c("seqnames","start","end", "strand"))
            irf[, start := start + 1]
            # Extra statistics:
            irf[, SpliceMax := 0]
            irf[SpliceLeft >= SpliceRight, SpliceMax := SpliceLeft]
            irf[SpliceLeft < SpliceRight, SpliceMax := SpliceRight]

            # junc = fst::read.fst(paste(norm_output_path, Experiment$sample[i], "junc.fst", sep="/"))
            # Determine SpliceOver using overlaps with obligate intronic regions
            # irf[junc, SpliceOver := i.SpliceOver, on = c("seqnames","start","end", "strand")]

            fst::write.fst(as.data.frame(irf), 
                paste(norm_output_path, Experiment$sample[i], "IR.fst", sep="/")
            )
        }    
    }
}

BuildSE = function(output_path, reference_path) {

    IR.df = FindSamples(output_path, "IR.fst", use_subdir = TRUE)
    colnames(IR.df)[2] = "IR_path"
    junc.df = FindSamples(output_path, "junc.fst", use_subdir = TRUE)
    colnames(junc.df)[2] = "junc_path"
    Experiment = dplyr::left_join(IR.df, junc.df, by = "sample")
    
    DT = as.data.table(fst::read.fst(Experiment$IR_path[1], c("seqnames", "start", "end", "Name", "strand")))
    
    for(i in seq_len(nrow(Experiment))) {
        temp.DT = as.data.table(fst::read.fst(Experiment$IR_path[i]))
        temp.DT[IntronDepth > 20.0, Threshold_Coverage := Coverage]
        DT[, c(paste(Experiment$sample[i], "Coverage", sep="_")) := temp.DT$Threshold_Coverage]
    }
    DT.Cov = as.matrix(DT[, -c("seqnames", "start", "end", "Name", "strand")])
    
}