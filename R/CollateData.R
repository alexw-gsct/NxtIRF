#' @export
FindSamples <- function(sample_path, suffix = ".txt.gz", use_subdir = FALSE) {
    assertthat::assert_that(dir.exists(sample_path),
        msg = "Given path does not exist")
    
    df = data.frame(sample = "", path = list.files(pattern = paste0("\\", suffix, "$"),
        path = normalizePath(sample_path), full.names = TRUE, recursive = TRUE))
    if(use_subdir) {
        df$sample = basename(dirname(df$path))
    } else {
        df$sample = sub(suffix,"",basename(df$path))
    }
    return(df)
}

#' Processes data from IRFinder output
#'
#' @param Experiment: A data frame containing the necessary information. The first column is the base name of the sample files. The second column is the sample name. All subsequent columns are assumed to be experimental conditions / annotation data (e.g. gender, age, treatment response, etc)
#' @param reference_path: THe path to the reference generated by BuildReference()
#' @param output_path: The path to the output generated by data collation.
#' @export
CollateData <- function(Experiment, reference_path, ah_genome, output_path) {
    assertthat::assert_that("data.frame" %in% class(Experiment),
        msg = "Experiment object needs to be a data frame")
    assertthat::assert_that(ncol(Experiment) >= 2,
        msg = "Experiment needs to contain two columns containing (1) sample name and (2) IRFinder output")
    
    colnames(Experiment)[1:2] = c("sample", "path")
    
    # Create a subdirectory for each sample within output_path
    base_output_path = normalizePath(dirname(output_path))      # TODO check if this fails
    norm_output_path = paste(base_output_path, basename(output_path), sep="/")
    if(!dir.exists(norm_output_path)) {
        dir.create(norm_output_path)
    }
    
    df.internal = Experiment[,1:2]
    df.internal$paired = FALSE
    df.internal$strand = 0
    df.internal$depth = 0

    for(i in 1:nrow(df.internal)) {
        message(paste("Processing stats of file ", i))
        stats = suppressWarnings(fread(df.internal$path[i], skip = "BAM"))
        stats$Value = as.numeric(stats$Value)
        if(stats$Value[3] == 0 & stats$Value[4] > 0) {
            df.internal$paired[i] = TRUE
            df.internal$depth[i] = stats$Value[4]
        } else if(stats$Value[3] > 0 && stats$Value[4] / stats$Value[3] / 1000) {
            df.internal$paired[i] = TRUE
            df.internal$depth[i] = stats$Value[4]
        } else {
            df.internal$paired[i] = FALSE
            df.internal$depth[i] = stats$Value[3]
        }
        direct = suppressWarnings(fread(df.internal$path[i], skip = "Directionality"))
        direct$Value = as.numeric(direct$Value)
        df.internal$strand[i] = direct$Value[9]
    }
    gc()
    
    if(any(df.internal$strand == 0)) {
        runStranded = FALSE
    } else {
        runStranded = TRUE
    }
    
    # Compile junctions and IR lists first, save to temp files
    for(i in 1:nrow(df.internal)) {
        message(paste("Compiling junction and IR lists from sample: ", i))
        junc = suppressWarnings(as.data.table(fread(df.internal$path[i], skip = "JC_seqname")))
        setnames(junc, "JC_seqname", "seqnames")
        if(!exists("junc.common")) {
            junc.common = junc[,1:4]
        } else {
            junc.common = merge(junc.common, junc[,1:4], all = T)
        }
		# Write temp file
        fst::write.fst(as.data.frame(junc), 
            paste(norm_output_path, paste(Experiment$sample[i], "junc.fst.tmp", sep="."), sep="/"))

        
		# Compile IRFinder based on strand
		if(!runStranded) {
            irf = suppressWarnings(as.data.table(fread(Experiment$path[i], skip = "Nondir_")))
            setnames(irf, c("Nondir_Chr", "Start", "End", "Strand"), c("seqnames","start","end", "strand"))
            if(!exists("irf.common")) {
                irf.common = irf[,1:6]
            } else {
                irf.common = semi_join.DT(irf.common, irf[,1:6], by = colnames(irf.common))
            }
		} else {
            irf = suppressWarnings(as.data.table(fread(Experiment$path[i], skip = "Dir_Chr")))
            setnames(irf, c("Dir_Chr", "Start", "End", "Strand"), c("seqnames","start","end", "strand"))
            if(!exists("irf.common")) {
                irf.common = irf[,1:6]
            } else {
                irf.common = semi_join.DT(irf.common, irf[,1:6], by = colnames(irf.common))
            }
		}
        fst::write.fst(as.data.frame(irf), 
            paste(norm_output_path, paste(Experiment$sample[i], "irf.fst.tmp", sep="."), sep="/"))
    }
    irf.common[, start := start + 1]

#   ah_genome = "AH65745"
    ah = AnnotationHub::AnnotationHub()
    genome = ah[[ah_genome]]

    junc.common[, start := start + 1]
    junc.common[strand == ".", strand := "*"]
    left.gr = GRanges(seqnames = junc.common$seqnames, 
        ranges = IRanges(start = junc.common$start, end = junc.common$start + 1), strand = "+")
    right.gr = GRanges(seqnames = junc.common$seqnames, 
        ranges = IRanges(start = junc.common$end - 1, end = junc.common$end), strand = "+")
        
    left.seq = BSgenome::getSeq(genome, left.gr)
    right.seq = BSgenome::getSeq(genome, right.gr)

    junc.common$motif_pos = paste0(as.character(left.seq), as.character(right.seq))
    junc.common$motif_infer_strand = "n"
    junc.common[ motif_pos %in% c("GTAG", "GCAG", "ATAC", "ATAG"), motif_infer_strand := "+"]
    junc.common[ motif_pos %in% c("CTAC", "CTGC", "GTAT", "CTAT"), motif_infer_strand := "-"]
    junc.common[ motif_pos %in% c("GTAC"), motif_infer_strand := "n"]       # Do not accept un-annotated GTACs - too confusing
    # Exclude non-splice motifs (that are also not annotated - i.e. strand == "*")
    junc.common = junc.common[motif_infer_strand != "n" | strand != "*"]

    # Use motif_infer_strand
    junc.common = junc.common[motif_infer_strand == "n", motif_infer_strand := strand]
    junc.common$strand = NULL
    setnames(junc.common, "motif_infer_strand", "strand")

    # Should splicing across gene groups be allowed? Exclude
    Genes = GenomicRanges::makeGRangesFromDataFrame(
        fst::read.fst(paste(reference_path, "fst", "Genes.fst", sep="/"))
    )

    # Exclude distant splice events:

    # Genes.Group.stranded = as.data.table(
        # GenomicRanges::reduce(c(Genes, GenomicRanges::flank(Genes, 5000),
        # GenomicRanges::flank(Genes, 5000, start = FALSE))
    # ))
    # setorder(Genes.Group.stranded, seqnames, start, strand)
    # Genes.Group.stranded[, gene_group_stranded := .I]
    
    # junc.common.left = copy(junc.common)
    # junc.common.left[, start := start - 1]
    # junc.common.left[, end := start + 1]
    # OL = suppressWarnings(
        # GenomicRanges::findOverlaps(
            # GenomicRanges::makeGRangesFromDataFrame(as.data.frame(junc.common.left)), 
            # GenomicRanges::makeGRangesFromDataFrame(as.data.frame(Genes.Group.stranded))
        # )
    # )
    # junc.common$gene_group_left[OL@from] = Genes.Group.stranded$gene_group_stranded[OL@to]

    # junc.common.right = copy(junc.common)
    # junc.common.right[, end := end + 1]
    # junc.common.right[, start := end - 1]
    # OL = suppressWarnings(
        # GenomicRanges::findOverlaps(
            # GenomicRanges::makeGRangesFromDataFrame(as.data.frame(junc.common.right)), 
            # GenomicRanges::makeGRangesFromDataFrame(as.data.frame(Genes.Group.stranded))
        # )
    # )
    # junc.common$gene_group_right[OL@from] = Genes.Group.stranded$gene_group_stranded[OL@to]
        

    # junc.common = junc.common[gene_group_left == gene_group_right & !is.na(gene_group_left)]
    # junc.common$gene_group_left = NULL
    # junc.common$gene_group_right = NULL
    
    # Assign region names to junctions:
    junc.common[, Event := paste0(seqnames, ":", start, "-", end, "/", strand)]
    
    # Annotate junctions
    candidate.introns = as.data.table(fst::read.fst(paste(reference_path, "fst", "junctions.fst", sep="/")))
    candidate.introns[, transcript_biotype_2 := transcript_biotype]
    candidate.introns[!(transcript_biotype %in% c("protein_coding", "processed_transcript",
        "lincRNA", "antisense", "nonsense_mediated_decay")), transcript_biotype_2 := "other"]

    candidate.introns[, transcript_biotype_2 := factor(transcript_biotype_2, c("protein_coding", "processed_transcript",
        "lincRNA", "antisense", "other", "nonsense_mediated_decay"), ordered = TRUE)]
        
    if("transcript_support_level" %in% colnames(candidate.introns)) {
        setorder(candidate.introns, transcript_biotype_2, transcript_support_level)
    } else {
        setorder(candidate.introns, transcript_biotype_2)    
    }
    introns.unique = unique(candidate.introns, by = c("seqnames", "start", "end", "width", "strand"))
    setorder(introns.unique, seqnames, start, end, strand)

    junc.annotation = introns.unique[junc.common, 
        c("seqnames", "start", "end", "strand", "transcript_id", "intron_number", "gene_name", "gene_id", "transcript_biotype"),
        on = c("seqnames", "start", "end", "strand")]
    
    # Use Exon Groups file to designate exon groups to all junctions
    Exon.Groups = GenomicRanges::makeGRangesFromDataFrame(
        fst::read.fst(paste(reference_path, "fst", "Exons.groups.fst", sep="/")),
        keep.extra.columns = TRUE)
    
    # Always calculate stranded for junctions
    # if(!runStranded) {
        # Exon.Groups = Exon.Groups[strand(Exon.Groups) == "*"]
    # } else {
        # Exon.Groups = Exon.Groups[strand(Exon.Groups) != "*"]    
    # }
    Exon.Groups.S = Exon.Groups[strand(Exon.Groups) != "*"]    
    
    junc.common.left = copy(junc.common)
    junc.common.left[, start := start - 1]
    junc.common.left[, end := start + 1]
    OL = suppressWarnings(
        GenomicRanges::findOverlaps(
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(junc.common.left)), 
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(Exon.Groups.S))
        )
    )
    junc.common$gene_group_left[OL@from] = Exon.Groups.S$gene_group[OL@to]
    junc.common$exon_group_left[OL@from] = Exon.Groups.S$exon_group[OL@to]

    junc.common.right = copy(junc.common)
    junc.common.right[, end := end + 1]
    junc.common.right[, start := end - 1]
    OL = suppressWarnings(
        GenomicRanges::findOverlaps(
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(junc.common.right)), 
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(Exon.Groups.S))
        )
    )
    junc.common$gene_group_right[OL@from] = Exon.Groups.S$gene_group[OL@to]
    junc.common$exon_group_right[OL@from] = Exon.Groups.S$exon_group[OL@to]
    
    junc.common[, JG_up := ""]
    junc.common[, JG_down := ""]
    junc.common[strand == "+" & !is.na(gene_group_left) & !is.na(exon_group_left), 
        JG_up := paste(gene_group_left, exon_group_left, sep="_")]
    junc.common[strand == "-" & !is.na(gene_group_right) & !is.na(exon_group_right), 
        JG_up := paste(gene_group_right, exon_group_right, sep="_")]
    junc.common[strand == "+" & !is.na(gene_group_right) & !is.na(exon_group_right), 
        JG_down := paste(gene_group_right, exon_group_right, sep="_")]
    junc.common[strand == "-" & !is.na(gene_group_left) & !is.na(exon_group_left), 
        JG_down := paste(gene_group_left, exon_group_left, sep="_")]

    junc.common$gene_group_left = NULL
    junc.common$gene_group_right = NULL
    junc.common$exon_group_left = NULL
    junc.common$exon_group_right = NULL
    
    irf.common.left = copy(irf.common)
    irf.common.left[, start := start - 1]
    irf.common.left[, end := start + 1]
    OL = suppressWarnings(
        GenomicRanges::findOverlaps(
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(irf.common.left)), 
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(Exon.Groups.S))
        )
    )
    irf.common$gene_group_left[OL@from] = Exon.Groups.S$gene_group[OL@to]
    irf.common$exon_group_left[OL@from] = Exon.Groups.S$exon_group[OL@to]

    irf.common.right = copy(irf.common)
    irf.common.right[, end := end + 1]
    irf.common.right[, start := end - 1]
    OL = suppressWarnings(
        GenomicRanges::findOverlaps(
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(irf.common.right)), 
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(Exon.Groups.S))
        )
    )
    irf.common$gene_group_right[OL@from] = Exon.Groups.S$gene_group[OL@to]
    irf.common$exon_group_right[OL@from] = Exon.Groups.S$exon_group[OL@to]
    
    irf.common[, JG_up := ""]
    irf.common[, JG_down := ""]
    irf.common[strand == "+" & !is.na(gene_group_left) & !is.na(exon_group_left), 
        JG_up := paste(gene_group_left, exon_group_left, sep="_")]
    irf.common[strand == "-" & !is.na(gene_group_right) & !is.na(exon_group_right), 
        JG_up := paste(gene_group_right, exon_group_right, sep="_")]
    irf.common[strand == "+" & !is.na(gene_group_right) & !is.na(exon_group_right), 
        JG_down := paste(gene_group_right, exon_group_right, sep="_")]
    irf.common[strand == "-" & !is.na(gene_group_left) & !is.na(exon_group_left), 
        JG_down := paste(gene_group_left, exon_group_left, sep="_")]

    irf.common$gene_group_left = NULL
    irf.common$gene_group_right = NULL
    irf.common$exon_group_left = NULL
    irf.common$exon_group_right = NULL
    
    if(!runStranded) {
        Exon.Groups = Exon.Groups[strand(Exon.Groups) == "*"]
    } else {
        Exon.Groups = Exon.Groups[strand(Exon.Groups) != "*"]    
    }
    irf.common.left = copy(irf.common)
    irf.common.left[, start := start - 1]
    irf.common.left[, end := start + 1]
    OL = suppressWarnings(
        GenomicRanges::findOverlaps(
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(irf.common.left)), 
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(Exon.Groups.S))
        )
    )
    irf.common$gene_group_left[OL@from] = Exon.Groups.S$gene_group[OL@to]
    irf.common$exon_group_left[OL@from] = Exon.Groups.S$exon_group[OL@to]

    irf.common.right = copy(irf.common)
    irf.common.right[, end := end + 1]
    irf.common.right[, start := end - 1]
    OL = suppressWarnings(
        GenomicRanges::findOverlaps(
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(irf.common.right)), 
            GenomicRanges::makeGRangesFromDataFrame(as.data.frame(Exon.Groups.S))
        )
    )
    irf.common$gene_group_right[OL@from] = Exon.Groups.S$gene_group[OL@to]
    irf.common$exon_group_right[OL@from] = Exon.Groups.S$exon_group[OL@to]
    
    irf.common[, IRG_up := ""]
    irf.common[, IRG_down := ""]
    irf.common[strand == "+" & !is.na(gene_group_left) & !is.na(exon_group_left), 
        IRG_up := paste(gene_group_left, exon_group_left, sep="_")]
    irf.common[strand == "-" & !is.na(gene_group_right) & !is.na(exon_group_right), 
        IRG_up := paste(gene_group_right, exon_group_right, sep="_")]
    irf.common[strand == "+" & !is.na(gene_group_right) & !is.na(exon_group_right), 
        IRG_down := paste(gene_group_right, exon_group_right, sep="_")]
    irf.common[strand == "-" & !is.na(gene_group_left) & !is.na(exon_group_left), 
        IRG_down := paste(gene_group_left, exon_group_left, sep="_")]
    irf.common$gene_group_left = NULL
    irf.common$gene_group_right = NULL
    irf.common$exon_group_left = NULL
    irf.common$exon_group_right = NULL

    Splice.Anno = as.data.table(fst::read.fst(paste(reference_path, "fst", "Splice.fst", sep="/")))
    candidate.introns[, Event1a := Event]
    candidate.introns[, Event2a := Event]
    Splice.Anno[candidate.introns, on = "Event1a", up_1a := paste(i.gene_group_stranded, 
        i.exon_group_stranded_upstream, sep="_")]
    Splice.Anno[candidate.introns, on = "Event1a", down_1a := paste(i.gene_group_stranded, 
        i.exon_group_stranded_downstream, sep="_")]
    Splice.Anno[candidate.introns, on = "Event2a", down_2a := paste(i.gene_group_stranded, 
        i.exon_group_stranded_downstream, sep="_")]
    
    Splice.Anno[EventType %in% c("MXE", "SE", "ALE", "A3SS"),
        JG_up := up_1a]
    Splice.Anno[EventType %in% c("SE", "AFE", "A5SS"),
        JG_down := down_1a]
    Splice.Anno[EventType %in% c("MXE"),
        JG_down := down_2a]
    
    Splice.Anno$up_1a = NULL
    Splice.Anno$down_1a = NULL
    Splice.Anno$down_2a = NULL
    Splice.Anno[, strand := tstrsplit(Event1a, split="/")[[2]]]
    
    rm(candidate.introns, introns.unique)
    gc()

    for(i in seq_len(nrow(df.internal))) {
        message(paste("Processing data for sample: ", i))
        junc = as.data.table(
            fst::read.fst(paste(norm_output_path, paste(Experiment$sample[i], "junc.fst.tmp", sep="."), sep="/"))
        )
        # setnames(junc, "JC_seqname", "seqnames")
        junc[, start := start + 1]
        junc$strand = NULL

        junc = junc[junc.common, on = colnames(junc.common)[1:3]]
        
        if(df.internal$strand[i] == 0) {
            junc$count = junc$total    
        } else if(df.internal$strand[i] == -1) {
            junc$count = 0
            junc[strand == "+", count := neg]
            junc[strand == "-", count := pos]
            junc[strand == "*", count := total]
        } else {
            junc$count = 0
            junc[strand == "+", count := pos]
            junc[strand == "-", count := neg]
            junc[strand == "*", count := total]    
        }
        junc[is.na(count), count := 0]
        junc = junc[,c("seqnames", "start", "end", "strand", "Event", "count")]
        junc = cbind(junc, junc.common[, c("JG_up", "JG_down")])
        junc[, SO_L := 0]
        junc[, SO_R := 0]
        junc[JG_up != "" & strand == "+", SO_L := sum(count), by = "JG_up"]
        junc[JG_down != "" & strand == "+", SO_R := sum(count), by = "JG_down"]
        junc[JG_up != "" & strand == "-", SO_R := sum(count), by = "JG_up"]
        junc[JG_down != "" & strand == "-", SO_L := sum(count), by = "JG_down"]
        
        fst::write.fst(as.data.frame(junc), 
            paste(norm_output_path, paste(Experiment$sample[i], "junc.fst", sep="."), sep="/"))
        
        splice = copy(Splice.Anno)
        
        splice[, count_Event1a := 0]
        splice[!is.na(Event1a), count_Event1a := junc$count[match(Event1a, junc$Event)]]
        splice[is.na(count_Event1a), count_Event1a := 0]
        splice[, count_Event2a := 0]
        splice[!is.na(Event2a), count_Event2a := junc$count[match(Event2a, junc$Event)]]
        splice[is.na(count_Event2a), count_Event2a := 0]
        splice[, count_Event1b := 0]
        splice[!is.na(Event1b), count_Event1b := junc$count[match(Event1b, junc$Event)]]
        splice[is.na(count_Event1b), count_Event1b := 0]
        splice[, count_Event2b := 0]
        splice[!is.na(Event2b), count_Event2b := junc$count[match(Event2b, junc$Event)]]
        splice[is.na(count_Event2b), count_Event2b := 0]

        splice[, count_JG_up := 0]
        splice[!is.na(JG_up) & strand == "+", count_JG_up := junc$SO_L[match(JG_up, junc$JG_up)]]
        splice[!is.na(JG_up) & strand == "-", count_JG_up := junc$SO_R[match(JG_up, junc$JG_up)]]
        splice[is.na(count_JG_up), count_JG_up := 0]
        splice[, count_JG_down := 0]
        splice[!is.na(JG_down) & strand == "-", count_JG_down := junc$SO_L[match(JG_down, junc$JG_down)]]
        splice[!is.na(JG_down) & strand == "+", count_JG_down := junc$SO_R[match(JG_down, junc$JG_down)]]
        splice[is.na(count_JG_down), count_JG_down := 0]

        # Splice participation: sum of two events compared to JG_up / JG_down
        splice[, partic_up := 0]
        splice[, partic_down := 0]

        splice[EventType %in% c("MXE", "SE", "ALE", "A3SS"), partic_up := count_Event1a + count_Event1b]
        splice[EventType %in% c("MXE"), partic_down := count_Event2a + count_Event2b]
        splice[EventType %in% c("SE"), partic_down := count_Event2a + count_Event1b]
        splice[EventType %in% c("AFE", "A5SS"), partic_down := count_Event1a + count_Event1b]

        fst::write.fst(as.data.frame(splice), 
            paste(norm_output_path, paste(Experiment$sample[i], "splice.fst", sep="."), sep="/"))

        # Example: require partic_up / JG_up > 0.6 and partic_down / JG_down > 0.6 and JG_up > 10, JG_down > 10
        # splice[, mainEvent := FALSE]
        # splice[EventType %in% c("MXE", "SE"), mainEvent := partic_up / count_JG_up > 0.6 & partic_down / count_JG_down / 0.6]
        # splice[EventType %in% c("MXE", "SE") & (count_JG_down < 10 | count_JG_up < 10), mainEvent := FALSE]

        # splice[EventType %in% c("ALE", "A3SS"), mainEvent := partic_up / count_JG_up > 0.6]
        # splice[EventType %in% c("ALE", "A3SS") & (count_JG_up < 10), mainEvent := FALSE]

        # splice[EventType %in% c("AFE", "A5SS"), mainEvent := partic_down / count_JG_down > 0.6]
        # splice[EventType %in% c("AFE", "A5SS") & (count_JG_down < 10), mainEvent := FALSE]

        # Also where there are two events, they should lie within certain percentage of each other
        # splice[EventType %in% c("MXE", "SE") & mainEvent == TRUE & (count_Event1a + count_Event2a > 10), 
            # mainEvent := (
                # (count_Event1a / count_Event2a > 0.5) & (count_Event1a / count_Event2a < 2.0)
                # )]
        # splice[EventType %in% c("MXE") & mainEvent == TRUE & (count_Event1b + count_Event2b > 10), 
            # mainEvent := (
                # (count_Event1b / count_Event2b > 0.5) & (count_Event1b / count_Event2b < 2.0)
                # )]
        
        # splice[, PSI := -1]
        # splice[EventType %in% c("MXE"), PSI := (count_Event1a + count_Event2a) /
            # (count_Event1a + count_Event2a + count_Event1b + count_Event2b)]
        # splice[EventType %in% c("SE"), PSI := (count_Event1a + count_Event2a) /
            # (count_Event1a + count_Event2a + (2 * count_Event1b))]
        # splice[!(EventType %in% c("MXE","SE")), PSI := (count_Event1a) /
            # (count_Event1a + count_Event1b)]
        # splice[PSI < 0 | !mainEvent, PSI := NA]
        
        irf = as.data.table(
            fst::read.fst(paste(norm_output_path, paste(Experiment$sample[i], "irf.fst.tmp", sep="."), sep="/"))
        )
        irf[, start := start + 1]
        irf = irf[irf.common, on = colnames(irf.common)[1:6]]
        
        # Extra statistics:
        irf[, SpliceMax := 0]
        irf[SpliceLeft >= SpliceRight, SpliceMax := SpliceLeft]
        irf[SpliceLeft < SpliceRight, SpliceMax := SpliceRight]

        irf[junc, on = c("seqnames", "start", "end", "strand"), SpliceOverLeft := SO_L]
        irf[junc, on = c("seqnames", "start", "end", "strand"), SpliceOverRight := SO_R]
        irf[SpliceOverLeft >= SpliceOverRight, SpliceOverMax := SpliceOverLeft]
        irf[SpliceOverLeft < SpliceOverRight, SpliceOverMax := SpliceOverRight]
        
        irf[, IROratio := 0]
        irf[IntronDepth < 1 & IntronDepth > 0 & (Coverage + SpliceOverMax) > 0, IROratio := Coverage / (Coverage + SpliceOverMax)]
        irf[IntronDepth >= 1, IROratio := IntronDepth / (IntronDepth + SpliceOverMax)]
        
		fst::write.fst(as.data.frame(irf),
            paste(norm_output_path, paste(Experiment$sample[i], "irf.fst", sep="."), sep="/"))
            
        file.remove(paste(norm_output_path, paste(Experiment$sample[i], "junc.fst.tmp", sep="."), sep="/"))
        file.remove(paste(norm_output_path, paste(Experiment$sample[i], "irf.fst.tmp", sep="."), sep="/"))
    }
}

#' @export
BuildSE = function(output_path, reference_path) {

    IR.df = as.data.table(FindSamples(output_path, ".irf.fst"))
    setnames(IR.df, "path", "IR_path")
    junc.df = as.data.table(FindSamples(output_path, ".junc.fst"))
    setnames(junc.df, "path", "junc_path")
    splice.df = as.data.table(FindSamples(output_path, ".splice.fst"))
    setnames(splice.df, "path", "splice_path")
    
    files = IR.df[junc.df[splice.df, on = "sample"], on = "sample"]
    
    # Load skinny annotation
    irf.anno = as.data.table(fst::read.fst(files$IR_path[1], 
        c("Name")))
    setnames(irf.anno, "Name", "EventName")
    irf.anno[, EventType := "IR"]
    splice.anno = as.data.table(fst::read.fst(files$splice_path[1],
        c("EventName", "EventType")))
    
    # Use a common index centered around c("EventName", "EventType")
    
    rowEvent = rbind(irf.anno[, c("EventName", "EventType")], splice.anno[, c("EventName", "EventType")])
    rowEvent.M = copy(rowEvent)
    rowEvent.Cov = copy(rowEvent)
    
    filter.Depth = copy(rowEvent)       # filter for .Cov > 20
    filter.Cov = copy(rowEvent)         # IR: filter for coverage > 0.9 if .Cov > 10
                                        # AS: filter for participation > 0.6
    
    for(i in seq_len(nrow(files))) {
        irf = as.data.table(fst::read.fst(files$IR_path[i], c("Name", "IntronDepth", "Coverage", "SpliceOverMax")))
        setnames(irf, "Name", "EventName")
        irf[, EventType := "IR"]
        splice = as.data.table(fst::read.fst(files$splice_path[i], c("EventName", "EventType", 
            "count_Event1a", "count_Event1b",
            "count_Event2a", "count_Event2b",
            "partic_up", "partic_down",
            "count_JG_up", "count_JG_down")))

        rowEvent.M[, c(files$sample[i]) := 0]
        rowEvent.M[irf[IntronDepth > 0 & IntronDepth < 1 & (Coverage + SpliceOverMax) > 0], 
            on = c("EventName", "EventType"),
            c(files$sample[i]) := Coverage]
        rowEvent.M[irf[IntronDepth >= 1], 
            on = c("EventName", "EventType"),
            c(files$sample[i]) := IntronDepth]

        rowEvent.M[splice[EventType %in% c("MXE", "SE")], 
            on = c("EventName", "EventType"),
            c(files$sample[i]) := count_Event1a + count_Event2a]
        rowEvent.M[splice[EventType %in% c("ALE", "AFE", "A3SS", "A5SS")], 
            on = c("EventName", "EventType"),
            c(files$sample[i]) := count_Event1a]

        rowEvent.Cov[, c(files$sample[i]) := 0]
        rowEvent.Cov[irf[IntronDepth > 0 & IntronDepth < 1 & (Coverage + SpliceOverMax) > 0], 
            on = c("EventName", "EventType"),
            c(files$sample[i]) := Coverage + SpliceOverMax]
        rowEvent.Cov[irf[IntronDepth >= 1], 
            on = c("EventName", "EventType"),
            c(files$sample[i]) := IntronDepth + SpliceOverMax]

        rowEvent.Cov[splice[EventType %in% c("MXE")], 
            on = c("EventName", "EventType"),
            c(files$sample[i]) := count_Event1a + count_Event2a + count_Event1b + count_Event2b]
        rowEvent.Cov[splice[EventType %in% c("SE")], 
            on = c("EventName", "EventType"),
            c(files$sample[i]) := count_Event1a + count_Event2a + 2 * count_Event1b]
        rowEvent.Cov[splice[EventType %in% c("ALE", "AFE", "A3SS", "A5SS")], 
            on = c("EventName", "EventType"),
            c(files$sample[i]) := count_Event1a + count_Event1b]
            
        filter.Depth[, c(files$sample[i]) := 0]
        filter.Depth[irf[IntronDepth + SpliceOverMax > 20],
            on = c("EventName", "EventType"),
            c(files$sample[i]) := 1]
        filter.Depth[splice[EventType %in% c("MXE", "SE") &
            count_JG_down > 20 & count_JG_up > 20],
            on = c("EventName", "EventType"),
            c(files$sample[i]) := 1]
        filter.Depth[splice[EventType %in% c("ALE", "A3SS") &
            count_JG_up > 20],
            on = c("EventName", "EventType"),
            c(files$sample[i]) := 1]
        filter.Depth[splice[EventType %in% c("AFE", "A5SS") &
            count_JG_down > 20],
            on = c("EventName", "EventType"),
            c(files$sample[i]) := 1]

        filter.Cov[, c(files$sample[i]) := 0]
        filter.Cov[irf[IntronDepth < 10 | Coverage > 0.9],
            on = c("EventName", "EventType"),
            c(files$sample[i]) := 1]
        filter.Cov[splice[EventType %in% c("MXE", "SE") &
            partic_up / count_JG_up > 0.6 & partic_down / count_JG_down / 0.6],
            on = c("EventName", "EventType"),
            c(files$sample[i]) := 1]
        filter.Cov[splice[EventType %in% c("ALE", "A3SS") &
            partic_up / count_JG_up > 0.6],
            on = c("EventName", "EventType"),
            c(files$sample[i]) := 1]
        filter.Cov[splice[EventType %in% c("AFE", "A5SS") &
            partic_down / count_JG_down > 0.6],
            on = c("EventName", "EventType"),
            c(files$sample[i]) := 1]
                }
    
    se = SummarizedExperiment::SummarizedExperiment(assays = SimpleList(
		M = rowEvent.M[, -1:-2], Cov = rowEvent.Cov[,-1:-2],
        filter.Depth = filter.Depth[,-1:-2], filter.Cov = filter.Cov[,-1:-2]
	), rowData = rowEvent, colData = files)
    rownames(se) = SummarizedExperiment::rowData(se)$EventName
    
    se
}