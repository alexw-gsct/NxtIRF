#' @export
FindSamples <- function(sample_path, suffix = ".txt.gz") {
    assertthat::assert_that(dir.exists(sample_path),
        msg = "Given path does not exist")
    
    df = data.frame(sample = "", path = list.files(pattern = paste0("\\", suffix, "$"),
        path = normalizePath(sample_path), full.names = TRUE, recursive = TRUE))
    df$sample = sub(suffix,"",basename(df$path))
    
    return(df)
}

#' Processes data from IRFinder output (Step 1: performs gene count and finds unannotated junctions)
#'
#' @param Experiment: A data frame containing the necessary information. The first column is the base name of the sample files. The second column is the sample name. All subsequent columns are assumed to be experimental conditions / annotation data (e.g. gender, age, treatment response, etc)
#' @param reference_path: THe path to the reference generated by BuildReference()
#' @param output_path: The path to the output generated by data collation. 
CollateData <- function(Experiment, reference_path, ah_genome, output_path) {
    assertthat::assert_that("data.frame" %in% class(Experiment),
        msg = "Experiment object needs to be a data frame")
    assertthat::assert_that(ncol(Experiment) >= 2,
        msg = "Experiment needs to contain two columns containing (1) sample name and (2) IRFinder output")
    
    colnames(Experiment)[1:2] = c("sample", "path")
    
    # Create a subdirectory for each sample within output_path
    base_output_path = normalizePath(dirname(output_path))      # TODO check if this fails
    norm_output_path = paste(base_output_path, basename(output_path), sep="/")
    if(!dir.exists(norm_output_path)) {
        dir.create(norm_output_path)
    }
    for(i in 1:nrow(Experiment)) {
        if(!dir.exists(paste(norm_output_path, Experiment$sample[i], sep="/"))) {
            dir.create(paste(norm_output_path, Experiment$sample[i], sep="/"))
        }
    }
    
    df.internal = Experiment[,1:2]
    df.internal$paired = FALSE
    df.internal$strand = 0
    df.internal$depth = 0

    for(i in 1:nrow(df.internal)) {
        message(paste("Processing stats of file ", i))
        stats = suppressWarnings(fread(df.internal$path[i], skip = "BAM"))
        stats$Value = as.numeric(stats$Value)
        if(stats$Value[3] == 0 & stats$Value[4] > 0) {
            df.internal$paired[i] = TRUE
            df.internal$depth[i] = stats$Value[4]
        } else if(stats$Value[3] > 0 && stats$Value[4] / stats$Value[3] / 1000) {
            df.internal$paired[i] = TRUE
            df.internal$depth[i] = stats$Value[4]
        } else {
            df.internal$paired[i] = FALSE
            df.internal$depth[i] = stats$Value[3]
        }
        direct = suppressWarnings(fread(df.internal$path[i], skip = "Directionality"))
        direct$Value = as.numeric(direct$Value)
        df.internal$strand[i] = direct$Value[9]
    }

    # Compile junctions first
    for(i in 1:nrow(df.internal)) {
        message(paste("Processing junctions for sample: ", i))
        junc = suppressWarnings(as.data.table(fread(df.internal$path[i], skip = "JC_seqname")))
        setnames(junc, "JC_seqname", "seqnames")
        if(!exists("junc.common")) {
            junc.common = junc[,1:4]
        } else {
            junc.common = merge(junc.common, junc[,1:4], all = T)
        }
    }
    
#    ah_genome = "AH65745"
    ah = AnnotationHub::AnnotationHub()
    genome = ah[[ah_genome]]

    junc.common[, start := start + 1]
    junc.common[strand == ".", strand := "*"]
    left.gr = GRanges(seqnames = junc.common$seqnames, 
        ranges = IRanges(start = junc.common$start, end = junc.common$start + 1), strand = "+")
    right.gr = GRanges(seqnames = junc.common$seqnames, 
        ranges = IRanges(start = junc.common$end - 1, end = junc.common$end), strand = "+")
        
    left.seq = BSgenome::getSeq(genome, left.gr)
    right.seq = BSgenome::getSeq(genome, right.gr)

    junc.common$motif_pos = paste0(as.character(left.seq), as.character(right.seq))
    junc.common$motif_infer_strand = "n"
    junc.common[ motif_pos %in% c("GTAG", "GCAG", "ATAC", "ATAG", "GTAC"), motif_infer_strand := "+"]
    junc.common[ motif_pos %in% c("CTAC", "CTGC", "GTAT", "CTAT", "GTAG"), motif_infer_strand := "-"]
    junc.common[ motif_pos %in% c("GTAC"), motif_infer_strand := "*"]
    # Exclude non-splice motifs
    junc.common = junc.common[motif_infer_strand != "n"]

    obligate.introns.stranded = fst::read.fst(paste(reference_path, "fst", "obligate.introns.stranded.fst", sep="/"))        
    obligate.introns.unstranded = fst::read.fst(paste(reference_path, "fst", "obligate.introns.unstranded.fst", sep="/"))        

    OL.stranded = suppressWarnings(GenomicRanges::findOverlaps(
        makeGRangesFromDataFrame(as.data.frame(obligate.introns.stranded)),
        makeGRangesFromDataFrame(as.data.frame(junc.common))
        ))
    OL.unstranded = suppressWarnings(GenomicRanges::findOverlaps(
        makeGRangesFromDataFrame(as.data.frame(obligate.introns.unstranded)),
        makeGRangesFromDataFrame(as.data.frame(junc.common)), 
        ignore.strand=TRUE))
    
    # remove obligate introns for which there is no overlap with current dataset
    obligate.introns.stranded = obligate.introns.stranded[unique(OL.stranded@from),]
    obligate.introns.unstranded = obligate.introns.unstranded[unique(OL.unstranded@from),]

    OL.stranded = suppressWarnings(GenomicRanges::findOverlaps(
        makeGRangesFromDataFrame(as.data.frame(obligate.introns.stranded)),
        makeGRangesFromDataFrame(as.data.frame(junc.common))
        ))
    OL.unstranded = suppressWarnings(GenomicRanges::findOverlaps(
        makeGRangesFromDataFrame(as.data.frame(obligate.introns.unstranded)),
        makeGRangesFromDataFrame(as.data.frame(junc.common)), 
        ignore.strand=TRUE))


    for(i in 1:nrow(df.internal)) {
        message(paste("Processing junctions for sample: ", i))
        junc = suppressWarnings(as.data.table(fread(df.internal$path[i], skip = "JC_seqname")))
        setnames(junc, "JC_seqname", "seqnames")
        junc[, start := start + 1]
        junc[strand == ".", strand := "*"]

        junc = junc[junc.common, on = colnames(junc.common)[1:4]]
        
        if(df.internal$strand[i] == 0) {
            junc$count = junc$total    
        } else if(df.internal$strand[i] == -1) {
            junc$count = 0
            junc[motif_infer_strand == "+", count := neg]
            junc[motif_infer_strand == "-", count := pos]
            junc[motif_infer_strand == "*", count := total]
        } else {
            junc$count = 0
            junc[motif_infer_strand == "+", count := pos]
            junc[motif_infer_strand == "-", count := neg]
            junc[motif_infer_strand == "*", count := total]    
        }
        junc[is.na(count), count := 0]
        junc = junc[,c("seqnames", "start", "end", "motif_infer_strand", "count")]
        setnames(junc, "motif_infer_strand", "strand")
        
        # Calculate SpliceOver here
        if(df.internal$strand[i] == 0) {
            junc.OL = data.table(from = OL.unstranded@from, to = OL.unstranded@to)
            OL = as.data.table(obligate.introns.unstranded)
        } else {
            junc.OL = data.table(from = OL.stranded@from, to = OL.stranded@to)
            OL = as.data.table(obligate.introns.stranded)
        }

        OL.expanded = OL[junc.OL$from]
        OL.expanded[, count := junc$count[junc.OL$to]]
        OL = OL.expanded[, lapply(.SD, sum, na.rm = TRUE), by = c("seqnames","start","end", "strand")]
        
        junc.expanded = junc[junc.OL$to]
        junc.expanded[, SpliceOver := OL$count[junc.OL$from]]
        junc.SO = junc.expanded[, lapply(.SD, mean, na.rm = TRUE), by = c("seqnames","start","end", "strand")]
        junc[junc.SO, SpliceOver := i.SpliceOver, on = c("seqnames","start","end", "strand")]
        junc[is.na(SpliceOver), SpliceOver := 0]

        fst::write.fst(as.data.frame(junc), 
            paste(norm_output_path, Experiment$sample[i], "junc.fst", sep="/"))
    }

    # Semi-join IRFinder annotation
    
    
    
    # Target files to generate
    
    # Set of IRFinder coverage files with guaranteed same row order for all samples
    # Unified junction counts for all samples
    # Unified gene counts for all samples

    # Create irf.common containing all rows found
    if(any(df.internal$strand == 0)) {
        for(i in 1:nrow(Experiment)) {
            message(paste("Processing file ", i))
            irf = suppressWarnings(as.data.table(fread(Experiment$path[i], skip = "Nondir_")))
            if(!exists("irf.common")) {
                irf.common = irf[,1:6]
            } else {
                irf.common = semi_join.DT(irf.common, irf[,1:6], by = colnames(irf.common))
            }
        }
        
        # Open each file again and left_merge with irf.common
        for(i in 1:nrow(Experiment)) {
            message(paste("Processing file ", i))
            irf = suppressWarnings(as.data.table(fread(Experiment$path[i], skip = "Nondir_")))
            irf = irf.common[irf, on = colnames(irf.common)[1:6]]
            fst::write.fst(as.data.frame(irf), 
                paste(norm_output_path, Experiment$sample[i], "IR.fst", sep="/")
            )
        }
    } else {
        for(i in 1:nrow(Experiment)) {
            message(paste("Processing file ", i))
            irf = suppressWarnings(as.data.table(fread(Experiment$path[i], skip = "Dir_Chr")))
            if(!exists("irf.common")) {
                irf.common = irf[,1:6]
            } else {
                irf.common = semi_join.DT(irf.common, irf[,1:6], by = colnames(irf.common))
            }
        }
        
        # Open each file again and left_merge with irf.common
        for(i in 1:nrow(Experiment)) {
            message(paste("Processing file ", i))
            irf = suppressWarnings(as.data.table(fread(Experiment$path[i], skip = "Dir_Chr")))
            irf = irf[irf.common, on = colnames(irf.common)[1:6]]
            setnames(irf, c("Dir_Chr", "Start", "End", "Strand"), c("seqnames","start","end", "strand"))
            irf[, start := start + 1]
            # Extra statistics:
            irf[, SpliceMax := 0]
            irf[SpliceLeft >= SpliceRight, SpliceMax := SpliceLeft]
            irf[SpliceLeft < SpliceRight, SpliceMax := SpliceRight]

            junc = fst::read.fst(paste(norm_output_path, Experiment$sample[i], "junc.fst", sep="/"))
            # Determine SpliceOver using overlaps with obligate intronic regions
            irf[junc, SpliceOver := i.SpliceOver, on = c("seqnames","start","end", "strand")]

            fst::write.fst(as.data.frame(irf), 
                paste(norm_output_path, Experiment$sample[i], "IR.fst", sep="/")
            )
        }    
    }
    
    # Repeat for junctions
    
}