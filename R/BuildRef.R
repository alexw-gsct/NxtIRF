############################################################
#
# BuildReference
# |- .fetch_genome_defaults
# |- .prep_ref_path
# |- .fetch_fasta
# |- .fetch_gtf
# |- .process_gtf
# |- .process_introns
# |- .gen_irf
# |- .gen_nmd
# |- .gen_splice
# |- .gen_splice_proteins


#' Builds reference files used by IRFinder / NxtIRF.
#'
#' @description
#' This function builds the reference required by the IRFinder engine, as well
#' as access-ready refined splice annotation data for NxtIRF. This reference
#' can be created using either:
#' 1. AnnotationHub genome and gene annotation (Ensembl): supply the names of
#'    the genome sequence `ah_genome` and gene annotations `ah_transcriptome`
#'    (see example below), or
#' 2. User-supplied FASTA and GTF file.
#' 
#' @param fasta: The path to the user-supplied genome fasta file
#' @param gtf: The path to the user-supplied transcript gtf file
#' @param ah_genome: The name of the AnnotationHub record containing the genome 2bit file.
#'   Leave blank to use user-supplied `fasta` file.
#' @param ah_transcriptome: The name of the AnnotationHub record containing the transcript gtf file
#'   Leave blank to use user-supplied `gtf` file.
#' @param reference_path: The directory to store the reference files
#' @param genome_type: Allows `BuildReference()` to select default `nonPolyARef` and `MappabilityRef`
#'   for selected genomes. Allowed options include: 'hg38', 'hg19', 'mm9', 'mm10'. Leave blank to
#'   supply custom `nonPolyARef` and `MappabilityRef` files
#' @param nonPolyARef: A BED file (3 unnamed columns containing chromosome, start and end 
#'   coordinates) of regions defining known non-polyadenylated transcripts. This file is used for
#'   QC analysis of IRFinder-processed files to measure Poly-A enrichment quality of samples.
#'   Leave blank to not use a `nonPolyARef` file (or to use default - see `genome_type`)
#' @param MappabilityRef: A BED file (3 unnamed columns containing chromosome, start and end 
#'   coordinates) of poorly-mapped regions due to repeat elements in the genome. We recommend
#'   using the default Mappability files supplied (see `genome_type`). Alternately, this
#'   reference can be generated by running `GenerateMappabilityReads()` on the genome sequence,
#'   followed by alignment of the produced fasta file to an aligner of choice (e.g. STAR, HISAT2).
#'   The aligned sequences (as BAM file) should then be analysed using `GenerateMappabilityBED()`,
#'   which will provide the Mappability file to be used here.
#' @param BlackListRef: A BED file (3 unnamed columns containing chromosome, start and end 
#'   coordinates) of regions to be otherwise excluded from IR analysis. Leave blank to not use a 
#'   `BlackListRef` file.
#' @param UseExtendedTranscripts: Should IRFinder include non-protein-coding transcripts such as
#'   anti-sense and lincRNAs? Setting `FALSE` (default IRFinder) will exclude transcripts other than 
#'   `protein_coding` and `processed_transcript` transcripts from IR analysis.
#' @param localHub: See `?AnnotationHub::AnnotationHub()`. Setting `TRUE` will run `AnnotationHub()`
#'   in offline mode
#' @param ah: An AnnotationHub object containing the records `ah_genome` and/or `ah_transcriptome`
#'   records to be used.
#' @param BPPARAM: A BPPARAM object for BiocParallel multi-threading.
#' @return Nothing. The created reference will be written to the given directory. This includes:
#' * `reference_path`/IRFinder.ref.gz: A gzipped text file containing collated IRFinder references 
#'   to be used as input for the IRFinder analysis
#' * `reference_path`/fst/: Contains fst files for subsequent easy access to NxtIRF generated
#'   references
#' * `reference_path`/resource/: Contains a TwoBitFile generated by this function for easy
#'   subsequent access to the genome. Only applies if user-supplied `fasta` file is used.
#' @examples
#' ## create an AnnotationHub object
#' ah = AnnotationHub::AnnotationHub()
#' 
#' ## filter for entries containing c("Homo Sapiens", "Ensembl", "release-94")
#' records = AnnotationHub::query(ah, c("Homo Sapiens", "Ensembl", "release-94"))
#' 
#' ## display summary of filtered records
#' print(records)
#' @seealso [GenerateMappabilityReads()], [GenerateMappabilityBED()], [AnnotationHub::AnnotationHub())]
#' @md
#' @export
BuildReference <- function(fasta = "genome.fa", gtf = "transcripts.gtf", 
    ah_genome = "", ah_transcriptome = "", reference_path = "./Reference",
    genome_type = "", nonPolyARef = "", MappabilityRef = "", BlacklistRef = "",
    UseExtendedTranscripts = TRUE,
    localHub = FALSE, ah = AnnotationHub(localHub = localHub), 
    BPPARAM = BiocParallel::bpparam()) {

    assert_that(genome_type != "",
        msg = paste("genome_type not specified.",
        "This should be either one of 'hg38', 'hg19', 'mm10', 'mm9', or",
        "'other'. If 'other', please provide a nonPolyARef file or leave",
        "blank to omit polyA profiling.")
    )

    extra_files = .fetch_genome_defaults(genome_type, nonPolyARef, 
        MappabilityRef, BlacklistRef, localHub, ah)

    assert_that(
        tryCatch(ifelse(normalizePath(dirname(reference_path)) != "",TRUE, TRUE),
            error = function(e) FALSE),
            msg = paste("Base path of ", reference_path, " does not exist"))

    .prep_ref_path(reference_path)
    
    N = 8
    dash_progress("Reading Reference Files",N)
    if(ah_genome != "") {
        genome = .fetch_fasta(ah_genome = ah_genome, 
            reference_path = reference_path, ah = ah)
        fasta_file = ""
    } else {
        genome = .fetch_fasta(fasta = fasta, 
            reference_path = reference_path, ah = ah)
        fasta_file = fasta
    }
    if(ah_transcriptome != "") {
        gtf_gr = .fetch_gtf(ah_transcriptome = ah_transcriptome, 
            reference_path = reference_path, ah = ah)
        gtf_file = ""
    } else {
        gtf_gr = .fetch_gtf(gtf = gtf, 
            reference_path = reference_path, ah = ah)
        gtf_file = gtf
    }

    # make sure all seqnames in gtf_gr is also in supplied genome
    chrOrder = names(seqinfo(genome))
    assert_that(any(as.character(GenomicRanges::seqnames(gtf_gr)) %in% chrOrder),
        msg = paste("Chromosomes in genome and gene annotation does not match",
            "likely incompatible FASTA and GTF file"))
    
    seqlevels(gtf_gr, pruning.mode = "tidy") <- chrOrder
    
    dash_progress("Processing gtf file",N)
    .process_gtf(gtf_gr, reference_path, genome)
    # To save memory, remove original gtf
    rm(gtf_gr)
    gc()

    dash_progress("Processing introns",N)
    .process_introns(reference_path, genome, UseExtendedTranscripts)
    gc()

# Finished annotating introns, now use it to build reference:
    dash_progress("Generating IRFinder Reference",N)
    .gen_irf(reference_path, extra_files, genome)

# Annotate IR-NMD
    dash_progress("Annotating IR-NMD",N)
    .gen_nmd(reference_path, genome)
    gc()
    
# Annotating Alternative Splicing Events
    dash_progress("Annotating Splice Events",N)
    .gen_splice(reference_path, genome)

    dash_progress("Translating AS Peptides",N)
    .gen_splice_proteins(reference_path, genome)

    message("Splice Annotations finished\n")
    message("Reference build finished")
    dash_progress("Reference build finished",N)

  # create settings.csv only after everything is finalised
    settings.list = list(
        fasta_file = fasta_file, gtf_file = gtf_file, 
        ah_genome = ah_genome, ah_transcriptome = ah_transcriptome,
        reference_path = reference_path, genome_type = genome_type, 
        nonPolyARef = nonPolyARef, MappabilityRef = MappabilityRef,
        BlacklistRef = BlacklistRef,
        UseExtendedTranscripts = UseExtendedTranscripts
    )
    saveRDS(settings.list, file.path(reference_path, "settings.Rds"))    
}

################################################################################

.fetch_genome_defaults <- function(genome_type, nonPolyARef, MappabilityRef,
        BlacklistRef, localHub = FALSE, ah = AnnotationHub::AnnotationHub(localHub = localHub)) {

    if(genome_type %in% c("hg38", "hg19", "mm9", "mm10")) {
        MappabilityFile = .fetch_mappability_file(genome_type, localHub, ah)
        if(genome_type == "hg38") {
            nonPolyAFile = system.file("extra-input-files/Human_hg38_nonPolyA_ROI.bed",
                package = "NxtIRF")
        } else if(genome_type == "hg19")  {
            nonPolyAFile = system.file("extra-input-files/Human_hg19_nonPolyA_ROI.bed", 
                package = "NxtIRF")
        } else if(genome_type == "mm10")  {
            nonPolyAFile = system.file("extra-input-files/Mouse_mm10_nonPolyA_ROI.bed", 
                package = "NxtIRF")
        } else if(genome_type == "mm9")  {
            nonPolyAFile = system.file("extra-input-files/Mouse_mm9_nonPolyA_ROI.bed",
                package = "NxtIRF")
        }
    } else {
        nonPolyAFile = 
            .parse_valid_file(nonPolyARef, "non-polyA reference")
        MappabilityFile = 
            .parse_valid_file(MappabilityRef, "Mappability reference")
    }

    BlacklistFile =  
        .parse_valid_file(BlacklistRef, "Blacklist exclusion")
 
    final = list(nonPolyAFile = nonPolyAFile, MappabilityFile = MappabilityFile,
        BlacklistFile = BlacklistFile)
    return(final)
}

.prep_ref_path <- function(reference_path) {
    base_output_path = normalizePath(dirname(reference_path))
    if(!dir.exists(file.path(base_output_path, basename(reference_path)))) {
        dir.create(file.path(base_output_path, basename(reference_path)))
    }
    if(!dir.exists(file.path(base_output_path, basename(reference_path), "fst"))) {
        dir.create(file.path(base_output_path, basename(reference_path), "fst"))
    }
}

.fetch_fasta <- function(reference_path = "./Reference",
        fasta = "", ah_genome = "", 
        localHub = FALSE, ah = AnnotationHub(localHub = localHub)) {
    genome = NULL
    if(ah_genome != "") {
        assert_that(substr(ah_genome,1,2) == "AH",
            msg = "Given genome AnnotationHub reference is incorrect")
        genome = .fetch_AH(ah_genome, ah = ah)
        message("done\n")
    } else {
        assert_that(file.exists(normalizePath(fasta)),
            msg = paste("Given genome fasta file", normalizePath(fasta),
                "not found"))
        # Convert genome to TwoBitFile for easy access:
        genome = Biostrings::readDNAStringSet(fasta)
        # Convert to local 2bit for better memory management
        if(!dir.exists(file.path(reference_path, "resource"))) {
            dir.create(file.path(reference_path, "resource"))
        }
        message("Converting genome to Twobit file", appendLF = FALSE)
        rtracklayer::export(genome, file.path(reference_path, "resource", 
            "genome.2bit"), "2bit")
        message("done\n")
    
        message("Connecting to genome TwoBitFile...", appendLF = FALSE)
        genome = rtracklayer::TwoBitFile(file.path(reference_path, "resource",
            "genome.2bit"))
        gc()
        message("done\n")
    }
    genome
}

.fetch_gtf <- function(reference_path = "./Reference",
        gtf = "", ah_transcriptome = "",
        localHub = FALSE, ah = AnnotationHub(localHub = localHub)) {
    gtf_gr = NULL
    if(ah_transcriptome != "") {
        assert_that(substr(ah_transcriptome,1,2) == "AH",
            msg = "Given transcriptome AnnotationHub reference is incorrect")
        gtf_gr = .fetch_AH(ah_transcriptome, ah = ah)
        message("done\n")
    } else {
        assert_that(file.exists(gtf),
            msg = paste("Given transcriptome gtf file", gtf,
                "not found"))
        gtf_file = gtf

        message("Reading source GTF file...", appendLF = FALSE)
        gtf_gr = rtracklayer::import(gtf, "gtf")
        message("done\n")
    }
    gc()
    gtf_gr
}

################################################################################

.fetch_AH <- function(ah_record_name, localHub = FALSE, 
    ah = AnnotationHub(localHub = localHub), verbose = FALSE) {

    assert_that(substr(ah_record_name, 1, 2) == "AH", msg = 
        paste(ah_record_name,
        "does not appear to be a valid AnnotationHub record name"))
    assert_that(ah_record_name %in% names(ah), msg = 
        paste(ah_record_name, 
            "is not found in AnnotationHub index.",
            "Perhaps check online connection or record name"))

    ah_record = ah[names(ah) == ah_record_name]

    if(verbose) message("Downloading asset from AnnotationHub, if required...", 
        appendLF = FALSE)
    cache_loc = AnnotationHub::cache(ah_record)
    if(verbose) message("done")
    
    assert_that(file.exists(cache_loc), 
        msg = "AnnotationHub cache error - asset not found")

    if(ah_record$rdataclass == "GRanges") {
        if(verbose) message("Importing to memory as GRanges object...", 
            appendLF = FALSE)
        gtf = rtracklayer::import(cache_loc, "gtf")
        if(verbose) message("done")
        return(gtf)
    } else if(ah_record$rdataclass == "TwoBitFile") {
        if(verbose) message("Importing to memory as GRanges object...", 
            appendLF = FALSE)
        twobit = rtracklayer::TwoBitFile(cache_loc)
        if(verbose) message("done")
        return(twobit)
    } else {
        message(paste(ah_record_name, 
            "does not appear to be a GRanges object or TwoBitFile,",
            "returning NULL"))
        return(NULL)
    }
}

.parse_valid_file <- function(file, msg) {
    if(!is_valid(file)) {
        message(paste(
            "Reference generated without", msg))
        return("")
    } else if(nchar(file) > 5 && substr(file, 1, 5) == "https") {
        url = file
        # BiocFileCache this and return file path
        cache <- rappdirs::user_cache_dir(appname="NxtIRF")
        bfc = BiocFileCache::BiocFileCache(cache, ask = FALSE)
        path <- BiocFileCache::bfcrpath(bfc, url)
        return(unname(path))
    } else if(!file.exists(file)) {
        message(paste(file, "not found.",
            "Reference generated without", msg))
        return("")
    } else if (file.exists(file)) {
        return(file)
    } else {
        message(paste(
            "Reference generated without", msg))
        return("")
    }
}

.fetch_mappability_file <- function(genome_type,
        localHub = FALSE, ah = AnnotationHub::AnnotationHub(localHub = localHub)) {

    resource_path = "https://raw.github.com/alexw-gsct/NxtIRF_resources/main/data"
    if(!(genome_type %in% c("hg38", "hg19", "mm9", "mm10"))) {
        MappabilityFile = ""
    } else {
        ah_record = ah[ah$genome == genome_type & 
            ah$sourceurl == resource_path]
        if(length(ah_record) == 1) {
            MappabilityFile = AnnotationHub::cache(ah_record)
        } else {
            if(genome_type == "hg38") {
                MappabilityFile = .parse_valid_file(
                    paste(resource_path, "Mappability_Regions_hg38_v94.txt.gz", sep="/"), 
                    "Mappability reference")
            } else if(genome_type == "hg19")  {
                MappabilityFile = .parse_valid_file(
                    paste(resource_path, "Mappability_Regions_hg19_v75.txt.gz", sep="/"), 
                    "Mappability reference")
            } else if(genome_type == "mm10")  {
                MappabilityFile = .parse_valid_file(
                    paste(resource_path, "Mappability_Regions_mm10_v94.txt.gz", sep="/"), 
                    "Mappability reference")
            } else if(genome_type == "mm9")  {
                MappabilityFile = .parse_valid_file(
                    paste(resource_path, "Mappability_Regions_mm9_v67.txt.gz", sep="/"), 
                    "Mappability reference")
            }        
        }
    }
    return(MappabilityFile)
}

.grDT <- function(DT, keep.extra.columns = FALSE, ignore.strand = FALSE) {
    # Converts data table to GRanges object, preserving info
    makeGRangesFromDataFrame(as.data.frame(DT),
        keep.extra.columns = keep.extra.columns,
        ignore.strand = ignore.strand)
}

.grlGaps<-function(grl) {
    psetdiff(unlist(range(grl),use.names=TRUE),grl)
}

################################################################################
.process_gtf <- function(gtf_gr, reference_path, genome) {
    # Extracting and saving Genes, Transcripts, Exons, Proteins 
    # and saving as .fst files for faster random access    
    message("Processing gtf file...", appendLF = FALSE)


    ########################################################
    # Genes
    # fix gene / transcript names with '/' (which breaks IRFinder code)
    gtf_gr$gene_name = gsub("/","_",gtf_gr$gene_name)
    gtf_gr$transcript_name = gsub("/","_",gtf_gr$transcript_name)

    Genes = gtf_gr[gtf_gr$type == "gene"]
    Genes <- GenomeInfoDb::sortSeqlevels(Genes)
    Genes <- sort(Genes)
    Genes$gene_display_name = paste0(Genes$gene_name, " (", Genes$gene_id, ")")

    # Annotate gene_groups_stranded
    Genes_group.stranded = as.data.table(reduce(Genes))
    setorder(Genes_group.stranded, seqnames, start, strand)

    Genes_group.stranded[, c("gene_group_stranded") := .I]
    OL = findOverlaps(
        Genes, .grDT(Genes_group.stranded))
    Genes$gene_group_stranded[from(OL)] =
        Genes_group.stranded$gene_group_stranded[to(OL)]

    # Annotate gene_groups_unstranded
    Genes_group.unstranded = as.data.table(reduce(Genes, ignore.strand = TRUE))
    setorder(Genes_group.unstranded, seqnames, start)
    Genes_group.unstranded[, c("gene_group_unstranded") := .I]
    OL = findOverlaps(Genes, 
        .grDT(Genes_group.unstranded, ignore.strand = TRUE))
    Genes$gene_group_unstranded[from(OL)] =
        Genes_group.unstranded$gene_group_unstranded[to(OL)]
    
    write.fst(as.data.frame(Genes), 
        file.path(reference_path,"fst","Genes.fst"))

    ########################################################
    # Transcripts        
    Transcripts = gtf_gr[gtf_gr$type == "transcript"]
    Transcripts <- GenomeInfoDb::sortSeqlevels(Transcripts)
    Transcripts <- sort(Transcripts)
    
    if("transcript_biotype" %in% names(mcols(Transcripts))) {
        # do nothing
    } else if("transcript_type" %in% names(mcols(Transcripts))) {
        colnames(mcols(Transcripts))[which(colnames(mcols(Transcripts)) == 
                "transcript_type")] = "transcript_biotype"
    } else {
        mcols(Transcripts)$transcript_biotype = "protein_coding"
    }
    if("transcript_support_level" %in% names(mcols(Transcripts))) {
        Transcripts$transcript_support_level =
            tstrsplit(Transcripts$transcript_support_level, split=" ")[[1]]
        Transcripts$transcript_support_level[
            is.na(Transcripts$transcript_support_level)] = "NA"
    }
   
    write.fst(as.data.frame(Transcripts),
        file.path(reference_path,"fst","Transcripts.fst"))

    ########################################################
    # Exons   
    Exons = gtf_gr[gtf_gr$type == "exon"]
    Exons <- GenomeInfoDb::sortSeqlevels(Exons)
    Exons <- sort(Exons)

    # transcript_biotype is very important field. 
    #    If Gencode, this is transcript_type.
    #   In rare case we do not have this field
    #   This next bit ensures transcript_biotype exists.
    if("transcript_biotype" %in% names(mcols(Exons))) {
        # do nothing
    } else if("transcript_type" %in% names(mcols(Exons))) {
        colnames(mcols(Exons))[
            which(colnames(mcols(Exons)) == "transcript_type")] = 
            "transcript_biotype"
    } else {
        mcols(Exons)$transcript_biotype = "protein_coding"
    }
    tmp.exons.exclude =  Exons[!grepl("intron", Exons$transcript_biotype)]

    # Assign gene groups then bake exon-groups into Exons
    tmp.Exons_group.stranded = as.data.table(reduce(tmp.exons.exclude))
    
    OL = findOverlaps(
        .grDT(tmp.Exons_group.stranded), 
        .grDT(Genes_group.stranded))
    tmp.Exons_group.stranded$gene_group[from(OL)] =
        Genes_group.stranded$gene_group_stranded[to(OL)]

    # Some retained_intron transcripts have terminal exons lying outside of
    #   main transcripts. Include these also
    tmp.exons.exclude.span = split(
      .grDT(tmp.Exons_group.stranded),
      tmp.Exons_group.stranded$gene_group)
    tmp.exons.exclude.span = 
        unlist(range(tmp.exons.exclude.span), use.names=TRUE)
 
    tmp.exons.RI =  Exons[grepl("intron", Exons$transcript_biotype)]
    if(length(tmp.exons.RI) > 0) {
        OL = findOverlaps(
            tmp.exons.RI, 
            tmp.exons.exclude.span
        )
        tmp.exons.RI = tmp.exons.RI[-from(OL)]
        tmp.exons.exclude = c(tmp.exons.exclude, tmp.exons.RI)
    # Reassign everything
        tmp.Exons_group.stranded = as.data.table(reduce(tmp.exons.exclude))
      
        OL = findOverlaps(
            .grDT(tmp.Exons_group.stranded), 
            .grDT(Genes_group.stranded)
        )
        tmp.Exons_group.stranded$gene_group[from(OL)] =
            Genes_group.stranded$gene_group_stranded[to(OL)]
    }

    setorder(tmp.Exons_group.stranded, seqnames, start, strand)
    tmp.Exons_group.stranded[, c("exon_group") := 
        data.table::rowid(get("gene_group"))]
    tmp.Exons_group.stranded[get("strand") == "-", 
        c("exon_group") := max(get("exon_group")) + 1 - get("exon_group"),
        by = "gene_group"]

    tmp.Exons_group.unstranded = as.data.table(reduce(tmp.exons.exclude,
        ignore.strand = TRUE))
    OL = findOverlaps(
        .grDT(tmp.Exons_group.unstranded), 
        .grDT(Genes_group.unstranded, ignore.strand = TRUE))
    tmp.Exons_group.unstranded$gene_group[from(OL)] =
        Genes_group.unstranded$gene_group_unstranded[to(OL)]
    setorder(tmp.Exons_group.unstranded, seqnames, start, strand)
    tmp.Exons_group.unstranded[, c("exon_group") := 
        data.table::rowid(get("gene_group"))]
    tmp.Exons_group.unstranded[strand == "-", 
        c("exon_group") := max(get("exon_group")) + 1 - get("exon_group"), 
        by = "gene_group"]

    # Now annotate all exons in Exons with the gene and exon groups
    OL = findOverlaps(
        Exons, .grDT(tmp.Exons_group.stranded))
    Exons$gene_group_stranded[from(OL)] =
        tmp.Exons_group.stranded$gene_group[to(OL)]
    Exons$exon_group_stranded[from(OL)] =
        tmp.Exons_group.stranded$exon_group[to(OL)]

    OL = findOverlaps(
        Exons, .grDT(tmp.Exons_group.unstranded,
        ignore.strand = TRUE))
    Exons$gene_group_unstranded[from(OL)] =
        tmp.Exons_group.unstranded$gene_group[to(OL)]
    Exons$exon_group_unstranded[from(OL)] =
        tmp.Exons_group.unstranded$exon_group[to(OL)]
    
    # Finally write to disk
    write.fst(as.data.frame(Exons), file.path(reference_path,"fst","Exons.fst"))
    # Also write tmp.Exon groups
    write.fst(rbind(tmp.Exons_group.stranded, tmp.Exons_group.unstranded), 
        file.path(reference_path,"fst","Exons_group.fst"))

    ########################################################
    # Proteins
    Proteins = gtf_gr[gtf_gr$type == "CDS"]
    Proteins <- GenomeInfoDb::sortSeqlevels(Proteins)
    Proteins <- sort(Proteins)
    write.fst(as.data.frame(Proteins),
        file.path(reference_path,"fst","Proteins.fst"))

    ########################################################
    # Misc
    gtf.misc = gtf_gr[!gtf_gr$type %in% c("gene", "transcript", "exon", "CDS")]
    gtf.misc <- GenomeInfoDb::sortSeqlevels(gtf.misc)
    gtf.misc <- sort(gtf.misc)
    write.fst(as.data.frame(gtf.misc),
        file.path(reference_path,"fst","Misc.fst"))
    
    message("done\n")
}

################################################################################
.overlaps_exon_island <- function(intron.DT, groups.DT, upstream = TRUE) {
    if(upstream) {
        intron.DT[get("strand") == "+", c("start") := get("intron_start") - 1]
        intron.DT[get("strand") == "+", c("end") := get("intron_start")]
        intron.DT[get("strand") == "-", c("start") := get("intron_end")]
        intron.DT[get("strand") == "-", c("end") := get("intron_end") + 1]    
    } else {
        intron.DT[get("strand") == "-", c("start") := get("intron_start") - 1]
        intron.DT[get("strand") == "-", c("end") := get("intron_start")]
        intron.DT[get("strand") == "+", c("start") := get("intron_end")]
        intron.DT[get("strand") == "+", c("end") := get("intron_end") + 1]    
    }
    OL = findOverlaps(
        .grDT(intron.DT), 
        .grDT(groups.DT)
    )
    return(OL)
}

################################################################################
.process_introns <- function(reference_path, genome, UseExtendedTranscripts) {
    message("Processing introns...", appendLF = FALSE)    

    # Import and prepare the data
    Exons = makeGRangesFromDataFrame(
        read.fst(file.path(reference_path,"fst","Exons.fst")),
        keep.extra.columns = TRUE
    )
    Transcripts = makeGRangesFromDataFrame(
        read.fst(file.path(reference_path,"fst","Transcripts.fst")),
        keep.extra.columns = TRUE
    )    
    Proteins = makeGRangesFromDataFrame(
        read.fst(file.path(reference_path,"fst","Proteins.fst")),
        keep.extra.columns = TRUE
    )
    Exons_group = makeGRangesFromDataFrame(
        read.fst(file.path(reference_path,"fst","Exons_group.fst")),
        keep.extra.columns = TRUE
    )
    Exons_group.stranded = Exons_group[strand(Exons_group) != "*"]
    Exons_group.unstranded = Exons_group[strand(Exons_group) == "*"]
    
    if(UseExtendedTranscripts == FALSE) {
        candidate.transcripts = Exons[Exons$transcript_biotype %in% 
            c("processed_transcript", "protein_coding")]
    } else {
        candidate.transcripts = Exons   
    }
    candidate.introns = .grlGaps(
        split(candidate.transcripts, candidate.transcripts$transcript_id)
    )
    candidate.introns = as.data.table(candidate.introns)    
    candidate.introns$group = NULL
    colnames(candidate.introns)[1] = "transcript_id"
    setorderv(candidate.introns, c("seqnames", "start", "end", "strand"))
    
    # Annotating Introns:       
    candidate.introns[,c("intron_number") := 
        data.table::rowid(get("transcript_id"))]
    candidate.introns[get("strand") == "-", 
        c("intron_number") := 
            max(get("intron_number")) + 1 - get("intron_number"), 
        by = "transcript_id"]
    candidate.introns[, c("intron_id") := 
        paste0(get("transcript_id"), "_Intron", get("intron_number"))]
    candidate.introns[as.data.table(Transcripts), on = "transcript_id", 
        c("gene_name", "gene_id", "transcript_name", "transcript_biotype") := 
        list(get("i.gene_name"), get("i.gene_id"), 
            get("i.transcript_name"), get("i.transcript_biotype"))]
    
    # Grab splice motifs at this point; filter by valid splice motifs
    donor.introns = data.frame(seqnames = candidate.introns$seqnames,
        start = ifelse(candidate.introns$strand == "+", 
            candidate.introns$start, candidate.introns$end - 1),
        stop = ifelse(candidate.introns$strand == "+",
            candidate.introns$start + 1, candidate.introns$end),
        strand = candidate.introns$strand)
    donor_seq = getSeq(genome, makeGRangesFromDataFrame(donor.introns))
    acceptor.introns = data.frame(seqnames = candidate.introns$seqnames,
        start = ifelse(candidate.introns$strand == "+", 
            candidate.introns$end - 1, candidate.introns$start),
        stop = ifelse(candidate.introns$strand == "+", 
            candidate.introns$end, candidate.introns$start + 1),
        strand = candidate.introns$strand)
    acceptor_seq = getSeq(genome, makeGRangesFromDataFrame(acceptor.introns))
    candidate.introns$splice_motif = paste0(donor_seq, acceptor_seq)

    # Do other annotations here:   
    candidate.introns[as.data.table(Transcripts), on = "transcript_id", 
        c("gene_name", "gene_id", "transcript_name") :=
        list(get("i.gene_name"), get("i.gene_id"), get("i.transcript_name"))]
    if("transcript_support_level" %in% names(mcols(Transcripts))) {
        candidate.introns[as.data.table(Transcripts), on = "transcript_id", 
            c("transcript_support_level") := 
            list(get("i.transcript_support_level"))]
        candidate.introns[, c("transcript_support_level") := 
            tstrsplit(get("transcript_support_level"), split=" ")[[1]]]
        candidate.introns[is.na(get("transcript_support_level")),
            c("transcript_support_level") := "NA"]
    }
    if("protein_id" %in% names(mcols(Proteins))) {
        candidate.introns[as.data.table(Proteins), on = "transcript_id", 
        c("protein_id") := list(get("i.protein_id"))]
    }
    if("ccds_id" %in% names(mcols(Exons))) {
        candidate.introns[as.data.table(Exons), on = "transcript_id", 
        c("ccds_id") := list(get("i.ccds_id"))]
    }

    # Cannot annotate candidate introns by min and max exon_groups
        # because retained introns will overlap one or more exon groups
        # need to walk start -=1, end += 1, then do the overlap thing
    candidate.introns[,c("intron_start") := get("start")]
    candidate.introns[,c("intron_end") := get("end")]

    candidate.introns$gene_group_stranded = NA
    candidate.introns$exon_group_stranded_upstream = NA
    candidate.introns$exon_group_stranded_downstream = NA        
    
    OL = .overlaps_exon_island(candidate.introns, 
        Exons_group.stranded, upstream = TRUE)
    candidate.introns$gene_group_stranded[from(OL)] =
        Exons_group.stranded$gene_group[to(OL)]
    candidate.introns$exon_group_stranded_upstream[from(OL)] =
        Exons_group.stranded$exon_group[to(OL)]        

    OL = .overlaps_exon_island(candidate.introns, 
        Exons_group.stranded, upstream = FALSE)
    candidate.introns$exon_group_stranded_downstream[from(OL)] =
        Exons_group.stranded$exon_group[to(OL)]        

    # Need fix for retained_introns or sense_intronic where junction extends 
    #   into the obligate introns
    tmp = .grDT(Exons_group.stranded, keep.extra.columns = TRUE)
    tmp.Introns_group.stranded = .grlGaps(
        split(tmp, tmp$gene_group)
    )
    tmp.Introns_group.stranded = as.data.table(tmp.Introns_group.stranded)
    setnames(tmp.Introns_group.stranded, "group_name", "gene_group")
    tmp.Introns_group.stranded[,c("intron_number") := 
        data.table::rowid(get("gene_group"))]
    tmp.Introns_group.stranded[get("strand") == "-", 
        c("intron_number") := 
            max(get("intron_number")) + 1 - get("intron_number"),
        by = "gene_group"]

    candidate.introns.subset =
        candidate.introns[is.na(get("exon_group_stranded_upstream"))]
    candidate.introns = 
        candidate.introns[!is.na(get("exon_group_stranded_upstream"))]
    
    OL = .overlaps_exon_island(candidate.introns.subset, 
        tmp.Introns_group.stranded, 
        upstream = TRUE)
    candidate.introns.subset$gene_group_stranded[from(OL)] =
        tmp.Introns_group.stranded$gene_group[to(OL)]
    candidate.introns.subset$exon_group_stranded_upstream[from(OL)] =
        tmp.Introns_group.stranded$intron_number[to(OL)]        

    candidate.introns = rbind(candidate.introns, candidate.introns.subset)

    candidate.introns.subset =
        candidate.introns[is.na(get("exon_group_stranded_downstream"))]
    candidate.introns =
        candidate.introns[!is.na(get("exon_group_stranded_downstream"))]
    
    OL = .overlaps_exon_island(candidate.introns.subset, 
        tmp.Introns_group.stranded, 
        upstream = FALSE)            
    candidate.introns.subset$exon_group_stranded_downstream[from(OL)] =
        tmp.Introns_group.stranded$intron_number[to(OL)] + 1        

    candidate.introns = rbind(candidate.introns, candidate.introns.subset)
    
# Now repeat the same for unstranded condition
    candidate.introns$gene_group_unstranded = NA
    candidate.introns$exon_group_unstranded_upstream = NA
    candidate.introns$exon_group_unstranded_downstream = NA

    OL = .overlaps_exon_island(candidate.introns, 
        Exons_group.unstranded, upstream = TRUE)
    candidate.introns$gene_group_unstranded[from(OL)] =
        Exons_group.unstranded$gene_group[to(OL)]
    candidate.introns$exon_group_unstranded_upstream[from(OL)] =
        Exons_group.unstranded$exon_group[to(OL)]        

    OL = .overlaps_exon_island(candidate.introns, 
        Exons_group.unstranded, upstream = FALSE)
    candidate.introns$exon_group_unstranded_downstream[from(OL)] =
        Exons_group.unstranded$exon_group[to(OL)]        

    # Need fix for retained_introns or sense_intronic where 
    #   junction extends into the obligate introns
    tmp = .grDT(Exons_group.unstranded, keep.extra.columns = TRUE)
    tmp.Introns_group.unstranded = .grlGaps(
        split(tmp, tmp$gene_group)
    )
    tmp.Introns_group.unstranded = 
        as.data.table(tmp.Introns_group.unstranded)
    setnames(tmp.Introns_group.unstranded,
        "group_name", "gene_group")
    tmp.Introns_group.unstranded[,
        c("intron_number") := data.table::rowid(get("gene_group"))]

    candidate.introns.subset =
        candidate.introns[is.na(get("exon_group_unstranded_upstream"))]
    candidate.introns =
        candidate.introns[!is.na(get("exon_group_unstranded_upstream"))]

    OL = .overlaps_exon_island(candidate.introns.subset, 
        tmp.Introns_group.unstranded, 
        upstream = TRUE)
    candidate.introns.subset$gene_group_unstranded[from(OL)] =
        tmp.Introns_group.unstranded$gene_group[to(OL)]
    candidate.introns.subset$exon_group_unstranded_upstream[from(OL)] =
        tmp.Introns_group.unstranded$intron_number[to(OL)]        

    candidate.introns = rbind(candidate.introns, candidate.introns.subset)

    candidate.introns.subset =
        candidate.introns[is.na(get("exon_group_unstranded_downstream"))]
    candidate.introns =
        candidate.introns[!is.na(get("exon_group_unstranded_downstream"))]
    
    OL = .overlaps_exon_island(candidate.introns.subset, 
        tmp.Introns_group.unstranded, 
        upstream = FALSE)
    candidate.introns.subset$exon_group_unstranded_downstream[from(OL)] =
        tmp.Introns_group.unstranded$intron_number[to(OL)] + 1        

    candidate.introns = rbind(candidate.introns, candidate.introns.subset)

    # reset
    candidate.introns[,c("start") := get("intron_start")]
    candidate.introns[,c("end") := get("intron_end")]
    candidate.introns[,c("Event") :=  paste0(
        get("seqnames"), ":", get("intron_start"), "-", 
        get("intron_end"), "/", get("strand"))]
    
    write.fst(candidate.introns, 
        file.path(reference_path,"fst","junctions.fst"))
    
    message("done\n")    
}

################################################################################
.gen_irf <- function(reference_path, extra_files, genome) {
    message("Generating ref-cover.bed ...", appendLF = FALSE)    

    # Generating IRFinder-base references
    Genes = makeGRangesFromDataFrame(
        read.fst(file.path(reference_path,"fst","Genes.fst")),
        keep.extra.columns = TRUE
    )
    Genes.rev = Genes
    strand(Genes.rev) = ifelse(strand(Genes.rev) == "+", "-", 
        ifelse(strand(Genes.rev) == "-", "+", "*")) # Invert strand
    Genes.Extended = reduce(c(flank(Genes.rev, 5000), 
        flank(Genes.rev, 1000, start = FALSE)))

    candidate.introns = as.data.table(
        read.fst(file.path(reference_path,"fst","junctions.fst"))
    )
    Exons = makeGRangesFromDataFrame(
        read.fst(file.path(reference_path,"fst","Exons.fst")),
        keep.extra.columns = TRUE
    )
    Transcripts = makeGRangesFromDataFrame(
        read.fst(file.path(reference_path,"fst","Transcripts.fst")),
        keep.extra.columns = TRUE
    )
    
    tmp.exons.exclude =  Exons[!grepl("intron", Exons$transcript_biotype)]

    candidate.introns = candidate.introns[get("transcript_biotype") %in% 
        c("protein_coding", "processed_transcript",
        "lincRNA", "antisense", "nonsense_mediated_decay")]

    candidate.introns[, c("transcript_biotype") := 
        factor(get("transcript_biotype"),
            c("protein_coding", "processed_transcript",
            "lincRNA", "antisense", "nonsense_mediated_decay"), 
            ordered = TRUE)]
        
    if("transcript_support_level" %in% colnames(candidate.introns)) {
        # Sort by tsl first, then reverse later
        setorderv(candidate.introns, 
            c("transcript_biotype", "transcript_support_level")) 
    } else {
        setorderv(candidate.introns, "transcript_biotype")
    }

    introns.unique = unique(candidate.introns,
        by = c("seqnames", "start", "end", "width", "strand"))
    setorderv(introns.unique, c("seqnames", "start", "end", "strand"))
    introns.unique = .grDT(introns.unique, keep.extra.columns=TRUE)
        
    setorderv(candidate.introns, c("seqnames", "start", "end", "strand"))
    
    exclude.directional = as.data.table(tmp.exons.exclude)
    exclude.directional = unique(exclude.directional,
        by = c("seqnames", "start", "end", "width", "strand"))
    exclude.directional[, c("start") := get("start") - 5]
    exclude.directional[, c("end") := get("end") + 5]
    
    exclude.directional.reverse = copy(exclude.directional)
    exclude.directional.reverse[get("strand") == "-", c("strand"):= "P"]
    exclude.directional.reverse[get("strand") == "+", c("strand"):= "-"]
    exclude.directional.reverse[get("strand") == "P", c("strand"):= "+"]

    exclude.omnidirectional = GenomicRanges::GRanges(NULL)
    
    if(extra_files$MappabilityFile != "") {
        exclude.omnidirectional = c(exclude.omnidirectional,
            rtracklayer::import(extra_files$MappabilityFile, "bed")
        )
    }
    if(extra_files$BlacklistFile != "") {
        exclude.omnidirectional = c(exclude.omnidirectional,
            rtracklayer::import(extra_files$BlacklistFile, "bed")
        )
    }
    # merge with any gaps <= 9
    exclude.omnidirectional =
        reduce(exclude.omnidirectional, min.gapwidth = 9)
    # clean introns by those lying completely within blacklist regions
    if(length(exclude.omnidirectional) > 0) {
        introns.unique.blacklisted = findOverlaps(introns.unique,
            exclude.omnidirectional, type = "within")
        introns.unique = introns.unique[-introns.unique.blacklisted@from] 
    }
    
    introns.unique.exon.dir = findOverlaps(introns.unique, 
        .grDT(exclude.directional), type = "within")
    introns.unique.exon.nd = findOverlaps(introns.unique, 
        .grDT(exclude.directional),
        type = "within", ignore.strand=TRUE)

    introns.unique$known_exon_dir =
        ( seq_len(length(introns.unique)) %in% introns.unique.exon.dir@from )
    introns.unique$known_exon_nd =
        ( seq_len(length(introns.unique)) %in% introns.unique.exon.nd@from )

    introns.unique.antiover = findOverlaps(introns.unique, Genes.rev)
    introns.unique.antinear = findOverlaps(introns.unique, Genes.Extended)

    introns.unique$antiover =
        ( seq_len(length(introns.unique)) %in% introns.unique.antiover@from )
    introns.unique$antinear =
        ( seq_len(length(introns.unique)) %in% introns.unique.antinear@from )

    # Now subset introns by punching holes using blacklist regions
    introns.unique$intron_width = BiocGenerics::width(introns.unique)

    # Remove introns less than 50 bp:
    introns.unique = introns.unique[BiocGenerics::width(introns.unique) > 50]

    # remove 5 bases from start & end
    BiocGenerics::start(introns.unique) =
        BiocGenerics::start(introns.unique) + 5
    BiocGenerics::end(introns.unique) =
        BiocGenerics::end(introns.unique) - 5

    introns.unique.dir = introns.unique
    introns.unique.nd = introns.unique
################################################################################

    # Dir
    if(length(exclude.omnidirectional) > 0) {
        introns.intersect.dir = GenomicRanges::intersect(introns.unique.dir, 
            c(exclude.omnidirectional,
            .grDT(exclude.directional)))
    } else {
        introns.intersect.dir = GenomicRanges::intersect(introns.unique.dir, 
            c(.grDT(exclude.directional)))    
    }
    introns.intersect.ol =
        findOverlaps(introns.unique.dir, introns.intersect.dir)
    # make a GRanges same size as the number of intersections
    introns.intersect.dir.final =
        introns.intersect.dir[to(introns.intersect.ol)]
    introns.intersect.dir.final$intron_id =
        introns.unique$intron_id[from(introns.intersect.ol)]

    introns.unique.dir.ID = 
        split(introns.unique.dir, introns.unique.dir$intron_id)
    introns.intersect.dir.ID = 
        split(introns.intersect.dir.final,
            introns.intersect.dir.final$intron_id)
    introns.unique.dir.ID.compare = introns.unique.dir.ID[
        names(introns.unique.dir.ID) %in% names(introns.intersect.dir.ID)
    ]

    # nd
    if(exists("exclude.omnidirectional")) {
        introns.intersect.nd = GenomicRanges::intersect(
            introns.unique.nd, c(
                exclude.omnidirectional, 
                .grDT(exclude.directional), 
                .grDT(exclude.directional.reverse)
            )
        )
    } else {
        introns.intersect.nd = GenomicRanges::intersect(
            introns.unique.nd, c(
                .grDT(exclude.directional), 
                .grDT(exclude.directional.reverse)
            )
        )    
    }
    introns.intersect.ol =
        findOverlaps(introns.unique.nd, introns.intersect.nd)
    # make a GRanges same size as the number of intersections
    introns.intersect.nd.final =
        introns.intersect.nd[to(introns.intersect.ol)]
    introns.intersect.nd.final$intron_id =
        introns.unique$intron_id[from(introns.intersect.ol)]

    introns.unique.nd.ID =
        split(introns.unique.nd, introns.unique.nd$intron_id)
    introns.intersect.nd.ID =
        split(introns.intersect.nd.final, introns.intersect.nd.final$intron_id)
    introns.unique.nd.ID.compare =
        introns.unique.nd.ID[
            names(introns.unique.nd.ID) %in% names(introns.intersect.nd.ID)
        ]

    # Dir setdiff   
    tmpdir.IntronCover =
        setdiff(introns.unique.dir.ID.compare, introns.intersect.dir.ID)
    # now add back introns that did not require intersection 
    #   (or would have been excluded as known-exons)
    tmpdir.IntronCover = c(tmpdir.IntronCover, 
        introns.unique.dir.ID[
            !(names(introns.unique.dir.ID) %in% names(introns.intersect.dir.ID))
        ],
        introns.unique.dir.ID[
            names(introns.unique.dir.ID) %in%
                introns.unique.dir$intron_id[
                    introns.unique.dir$known_exon_dir == TRUE
                ]
        ]
    )

    tmpdir.IntronCover = as.data.table(tmpdir.IntronCover)
    tmpdir.IntronCover = tmpdir.IntronCover[,
        c("seqnames", "start", "end", "strand", "width", "group_name")]
    colnames(tmpdir.IntronCover)[6] = "intron_id"

    tmpdir.IntronCover.summa = tmpdir.IntronCover
    tmpdir.IntronCover.summa[, 
        c("num_blocks", "inclbases") := list(.N, sum(get("width"))), 
        by = "intron_id"]
    tmpdir.IntronCover.summa = unique(
        tmpdir.IntronCover.summa[,c("intron_id", "num_blocks", "inclbases")],
        by = "intron_id")
    tmpdir.IntronCover.summa[as.data.table(introns.unique), on = "intron_id", 
        c("seqnames", "intron_start", "intron_end",
            "intron_width", "width", "strand", "gene_name", "transcript_id",
            "known_exon_dir", "GG", "EG_up", "EG_down")
        := list(
            get("i.seqnames"), get("i.intron_start"), 
            get("i.intron_end"), get("i.intron_width"),
            get("i.width"), get("i.strand"), get("i.gene_name"), 
            get("i.transcript_id"), get("i.known_exon_dir"),
            get("i.gene_group_stranded"), get("i.exon_group_stranded_upstream"),
            get("i.exon_group_stranded_downstream")
        )]
    tmpdir.IntronCover.summa[, c("exclbases") := 
        get("intron_width") - get("inclbases")]
        # Exclude exclbases / width > 0.3
    tmpdir.IntronCover.summa = 
        tmpdir.IntronCover.summa[get("exclbases") / get("intron_width") < 0.3]

    tmpdir.IntronCover = semi_join.DT(
        tmpdir.IntronCover, tmpdir.IntronCover.summa,
        by = "intron_id")
 
    tmpdir.IntronCover.summa[, c("IRFname") := 
        paste("dir", get("gene_name"), get("intron_id"),
            get("strand"), get("num_blocks"), 
            sprintf("%.f", get("intron_start") - 1), 
            sprintf("%.f", get("intron_end")),
            get("inclbases"), get("exclbases"),
            ifelse(get("known_exon_dir"), "known-exon","clean"), sep="/")]

    tmpdir.IntronCover = makeGRangesFromDataFrame(
        tmpdir.IntronCover, keep.extra.columns=TRUE)
    tmpdir.IntronCover = split(tmpdir.IntronCover, tmpdir.IntronCover$intron_id)

    names(tmpdir.IntronCover) = tmpdir.IntronCover.summa$IRFname[match(
        names(tmpdir.IntronCover), tmpdir.IntronCover.summa$intron_id)]


    # Nondir setdiff
    tmpnd.IntronCover = 
        setdiff(introns.unique.nd.ID.compare, introns.intersect.nd.ID)
    # now add back introns that did not require intersection
    tmpnd.IntronCover = c(tmpnd.IntronCover, 
        introns.unique.nd.ID[
            !(names(introns.unique.nd.ID) %in% names(introns.intersect.nd.ID))
        ],
        introns.unique.nd.ID[
            names(introns.unique.nd.ID) %in% 
                introns.unique.nd$intron_id[
                    introns.unique.dir$known_exon_nd == TRUE
                ]
        ]
    )

    tmpnd.IntronCover = as.data.table(tmpnd.IntronCover)
    tmpnd.IntronCover = tmpnd.IntronCover[,
        c("seqnames", "start", "end", "strand", "width", "group_name")]
    colnames(tmpnd.IntronCover)[6] = "intron_id"

    tmpnd.IntronCover.summa = tmpnd.IntronCover
    tmpnd.IntronCover.summa[, 
        c("num_blocks", "inclbases") := list(.N, sum(get("width"))), 
        by = "intron_id"]
    tmpnd.IntronCover.summa = unique(
        tmpnd.IntronCover.summa[
            ,c("intron_id", "num_blocks", "inclbases")
        ], by = "intron_id")
        
    tmpnd.IntronCover.summa[as.data.table(introns.unique), on = "intron_id", 
        c("seqnames","intron_start", "intron_end",
            "intron_width", "width", "strand", "gene_name", "transcript_id",
            "known_exon_nd", "antiover", "antinear", "GG", "EG_up", "EG_down")
        := list(
            get("i.seqnames"), get("i.intron_start"), 
            get("i.intron_end"), get("i.intron_width"),
            get("i.width"), get("i.strand"), get("i.gene_name"), 
            get("i.transcript_id"),
            get("i.known_exon_nd"), get("i.antiover"), get("i.antinear"), 
            get("i.gene_group_unstranded"),
            get("i.exon_group_unstranded_upstream"),
            get("i.exon_group_unstranded_downstream")
        )]
    tmpnd.IntronCover.summa[, c("exclbases") := 
        get("intron_width") - get("inclbases")]
        # Exclude exclbases / width > 0.3
    tmpnd.IntronCover.summa = 
        tmpnd.IntronCover.summa[get("exclbases") / get("intron_width") < 0.3]

    tmpnd.IntronCover = semi_join.DT(
        tmpnd.IntronCover, tmpnd.IntronCover.summa,
        by = "intron_id")
 
    tmpnd.IntronCover.summa[, c("IRFname") := paste("nd", 
        get("gene_name"), get("intron_id"),
        get("strand"), get("num_blocks"), 
        sprintf("%.f", get("intron_start") - 1), 
        sprintf("%.f", get("intron_end")),
        get("inclbases"), get("exclbases"),
        sep="/")]
    # casewise naming of last condition
    tmpnd.IntronCover.summa[
        get("known_exon_nd") & get("antiover") & get("antinear"), 
        c("IRFname") := paste(get("IRFname"), 
            "known-exon+anti-over+anti-near",sep="/")]
    tmpnd.IntronCover.summa[
        get("known_exon_nd") & get("antiover") & !get("antinear"), 
        c("IRFname") := paste(get("IRFname"), 
            "known-exon+anti-over",sep="/")]
    tmpnd.IntronCover.summa[
        get("known_exon_nd") & !get("antiover") & get("antinear"), 
        c("IRFname") := paste(get("IRFname"), 
            "known-exon+anti-near",sep="/")]
    tmpnd.IntronCover.summa[
        !get("known_exon_nd") & get("antiover") & get("antinear"), 
        c("IRFname") := paste(get("IRFname"), 
            "anti-over+anti-near",sep="/")]
    tmpnd.IntronCover.summa[
        !get("known_exon_nd") & !get("antiover") & get("antinear"), 
        c("IRFname") := paste(get("IRFname"), 
            "anti-near",sep="/")] 
    tmpnd.IntronCover.summa[
        !get("known_exon_nd") & get("antiover") & !get("antinear"), 
        c("IRFname") := paste(get("IRFname"), 
            "anti-over",sep="/")]
    tmpnd.IntronCover.summa[
        get("known_exon_nd") & !get("antiover") & !get("antinear"), 
        c("IRFname") := paste(get("IRFname"), 
            "known-exon",sep="/")]
    tmpnd.IntronCover.summa[
        !get("known_exon_nd") & !get("antiover") & !get("antinear"), 
        c("IRFname") := paste(get("IRFname"), 
            "clean",sep="/")]

    tmpnd.IntronCover = makeGRangesFromDataFrame(
        tmpnd.IntronCover, keep.extra.columns=TRUE)
    tmpnd.IntronCover = split(tmpnd.IntronCover, tmpnd.IntronCover$intron_id)

    names(tmpnd.IntronCover) = tmpnd.IntronCover.summa$IRFname[match(
        names(tmpnd.IntronCover), tmpnd.IntronCover.summa$intron_id)]

    # Sort and Export out
    setorderv(tmpnd.IntronCover.summa, c("seqnames",
        "intron_start", "intron_end", "strand"))
    tmpnd.IntronCover = tmpnd.IntronCover[tmpnd.IntronCover.summa$IRFname]
    
    setorderv(tmpdir.IntronCover.summa, c("seqnames",
        "intron_start", "intron_end", "strand"))
    tmpdir.IntronCover = tmpdir.IntronCover[tmpdir.IntronCover.summa$IRFname]

    rtracklayer::export(tmpdir.IntronCover, file.path(reference_path,
        "tmpdir.IntronCover.bed"))
    rtracklayer::export(tmpnd.IntronCover, file.path(reference_path,
        "tmpnd.IntronCover.bed"))

    # Generate final ref-cover.bed
    tmpdir.IntronCover = fread(file.path(reference_path,
        "tmpdir.IntronCover.bed"), sep="\t")
    tmpdir.IntronCover[, c("cat") := "dir"]
    tmpnd.IntronCover = fread(file.path(reference_path,
        "tmpnd.IntronCover.bed"), sep="\t")
    tmpnd.IntronCover[, c("cat") := "nd"]

    ref.cover = rbind(tmpdir.IntronCover, tmpnd.IntronCover)
    setorderv(ref.cover, c("V1", "V2", "V3", "V6", "cat"))
    ref.cover$cat = NULL
    ref.cover[, c("V9") := as.character(get("V9"))]
    ref.cover[, c("V9") := "255,0,0"]

    # cleanup
    if(file.exists(file.path(reference_path, "tmpdir.IntronCover.bed"))) {
        file.remove(file.path(reference_path, "tmpdir.IntronCover.bed"))
    }
    if(file.exists(file.path(reference_path, "tmpnd.IntronCover.bed"))){
        file.remove(file.path(reference_path, "tmpnd.IntronCover.bed"))
    }
    
    # Now compile list of IRFinder introns here
    write.fst(tmpnd.IntronCover.summa, file.path(reference_path, "fst",
        "Introns.ND.fst"))
    write.fst(tmpdir.IntronCover.summa, file.path(reference_path, "fst",
        "Introns.Dir.fst"))

    message("done\n")

    message("Generating ref-ROI.bed ...", appendLF = FALSE)    

    # ROI
    if("gene_biotype" %in% names(mcols(Transcripts))) {
        rRNA = as.data.frame(Transcripts[grepl("rRNA",
            Transcripts$gene_biotype)])
        rRNA$start = rRNA$start - 1
        rRNA$name = with(rRNA, paste("rRNA", seqnames, start, end, strand,
            transcript_id, gene_biotype, gene_id, gene_name, sep="/"))
        rRNA = rRNA[, c("seqnames", "start", "end", "name")]
    } else if("gene_type" %in% names(mcols(Transcripts))) {
        rRNA = as.data.frame(Transcripts[grepl("rRNA", Transcripts$gene_type)])
        rRNA$start = rRNA$start - 1
        rRNA$name = with(rRNA, paste("rRNA", seqnames, start, end, strand,
            transcript_id, gene_type, gene_id, gene_name, sep="/"))
        rRNA = rRNA[, c("seqnames", "start", "end", "name")]    
    } else {
        rRNA = c()
    }
    
    nonPolyA = GenomicRanges::GRanges(NULL)
    if(extra_files$nonPolyAFile != "") {
        nonPolyA = c(nonPolyA,
            rtracklayer::import(extra_files$nonPolyAFile, "bed")
        )
        nonPolyA = as.data.frame(nonPolyA)
        nonPolyA = nonPolyA[, c("seqnames", "start", "end")]
        nonPolyA$name = "NonPolyA"
    } else {
        nonPolyA = c()
    }
    
    AllChr = data.frame(seqnames = names(seqinfo(genome)),
        start = 1, end = seqinfo(genome)@seqlengths,
        names = names(seqinfo(genome)))
    AllChr = makeGRangesListFromDataFrame(AllChr, split.field = "names")
    Genes.chr = c(Genes, flank(Genes, 10000),
        flank(Genes, 10000, start = FALSE))
    Genes.chr = reduce(Genes.chr, min.gapwidth = 1000)
    Genes.chr$chr = seqnames(Genes.chr)
    Genes.chr = split(Genes.chr, Genes.chr$chr)
    
    AllChr = AllChr[names(Genes.chr)]
    AllChr.split = setdiff(AllChr, Genes.chr, ignore.strand = TRUE)
    Intergenic = unlist(AllChr.split)
    if(length(Intergenic) > 0) {
        names(Intergenic) = seq_len(length(Intergenic))
        Intergenic = as.data.frame(Intergenic)
        Intergenic = Intergenic[,c("seqnames", "start", "end")]
        Intergenic$name = paste("Intergenic", Intergenic$seqnames, sep="/")
    } else {
        Intergenic = c()
    }
    ref.ROI = rbind(rRNA, nonPolyA, Intergenic) %>%
        dplyr::arrange(seqnames, start)
    
    ref.ROI$start = ref.ROI$start - 1   # convert back to 0-based
    message("done\n")

    message("Generating ref-read-continues.ref ...", appendLF = FALSE)    
    

    # ref-read-continues.ref
    introns.unique.readcons = rbind(
        tmpdir.IntronCover.summa[,
            c("seqnames", "intron_start", "intron_end", "strand")],
        tmpnd.IntronCover.summa[,
            c("seqnames", "intron_start", "intron_end", "strand")])
    # 0-based
    introns.unique.readcons[, c("intron_start") := get("intron_start") - 1]
        
    readcons.left = introns.unique.readcons[,
        c("seqnames", "intron_start", "strand")]
    readcons.right = introns.unique.readcons[,
        c("seqnames", "intron_end", "strand")]
    colnames(readcons.left) = c("V1", "V2", "V3")
    colnames(readcons.right) = c("V1", "V2", "V3")
    readcons = rbind(readcons.left, readcons.right)
    setorderv(readcons, c("V1", "V2", "V3"))
    readcons = unique(readcons)
    
    message("done\n")

    message("Generating ref-sj.ref ...", appendLF = FALSE)    
    
    # ref-sj.ref
    # Reload candidate introns here, as we've filtered this before
    candidate.introns = as.data.table(
        read.fst(file.path(reference_path,"fst","junctions.fst")))

    ref.sj = candidate.introns[,c("seqnames", "start", "end", "strand")]
    # annotate NMD-unique junctions

    ref.sj$Is_NMD = ifelse(
            grepl("nonsense_mediated_decay", 
                candidate.introns$transcript_biotype),
        "NMD", "")

    ref.sj = ref.sj[, lapply(.SD, function(x) {
            ifelse(all(x != ""), "NMD", "")
        }), by = c("seqnames", "start", "end", "strand")]
    
    ref.sj[,c("start") := get("start") - 1]

    message("done\n")
    
    IRF_file = file.path(reference_path, "IRFinder.ref.gz")
    # Concatenate all 4 reference files into one file
    fwrite(list(">ref-cover.bed"), IRF_file, 
        sep="\t", eol = "\n", col.names = F, scipen = 50)
    fwrite(ref.cover, IRF_file, append = TRUE, 
        sep="\t", eol = "\n", col.names = F, scipen = 50)
    fwrite(list(">ref-read-continues.ref"), IRF_file, append = TRUE, 
        sep="\t", eol = "\n", col.names = F, scipen = 50)
    fwrite(readcons, IRF_file, append = TRUE, 
        sep="\t", eol = "\n", col.names = F, scipen = 50)
    fwrite(list(">ref-ROI.bed"), IRF_file, append = TRUE, 
        sep="\t", eol = "\n", col.names = F, scipen = 50)
    fwrite(ref.ROI, IRF_file, append = TRUE, 
        sep="\t", eol = "\n", col.names = F, scipen = 50)
    fwrite(list(">ref-sj.ref"), IRF_file, append = TRUE, 
        sep="\t", eol = "\n", col.names = F, scipen = 50)
    fwrite(ref.sj, IRF_file, append = TRUE, 
        sep="\t", eol = "\n", col.names = F, scipen = 50)    

}

.gen_nmd = function(reference_path, genome) {
    Exons.tr = as.data.table(
        read.fst(file.path(reference_path,"fst","Exons.fst"))
    )
    candidate.introns = as.data.table(
        read.fst(file.path(reference_path,"fst","junctions.fst"))
    )
    Misc = as.data.table(
        read.fst(file.path(reference_path,"fst","Misc.fst"))
    )
    start.DT = Misc[get("type") == "start_codon"]

    Exons.tr = Exons.tr[get("transcript_id") %in% start.DT$transcript_id]
    
    Exons.tr[start.DT, on = c("transcript_id"), 
      c("sc_start", "sc_end") := list(get("i.start"), get("i.end"))]    
    Exons.tr[get("start") < get("sc_start") & get("strand") == "+", 
        c("start") := get("sc_start")]
    Exons.tr[get("end") < get("sc_start") & get("strand") == "+", 
        c("end") := get("sc_start")]
    Exons.tr[get("start") > get("sc_end") & get("strand") == "-", 
        c("start") := get("sc_end")]
    Exons.tr[get("end") > get("sc_end") & get("strand") == "-", 
        c("end") := get("sc_end")]
    Exons.tr = Exons.tr[get("start") < get("end")]
    
    protein.introns = candidate.introns[
        get("transcript_id") %in% Exons.tr$transcript_id]
    # determine here whether protein introns are CDS, 5' or 3' UTR introns
    UTR5 = Misc[get("type") == "five_prime_utr"]
    UTR5.introns = .grlGaps(
        split(makeGRangesFromDataFrame(as.data.frame(UTR5)),
            UTR5$transcript_id)
    )
    UTR5.introns = as.data.table(UTR5.introns)
    UTR3 = Misc[get("type") == "three_prime_utr"]
    UTR3.introns = .grlGaps(
        split(makeGRangesFromDataFrame(as.data.frame(UTR3)),
            UTR3$transcript_id)
    )
    UTR3.introns = as.data.table(UTR3.introns)
    
    CDS.introns = .grlGaps(
        split(makeGRangesFromDataFrame(as.data.frame(Exons.tr)),
            Exons.tr$transcript_id)
    )
    CDS.introns = as.data.table(CDS.introns)
    
    protein.introns[UTR5.introns, 
        on = c("seqnames", "start", "end", "strand"),
            c("intron_type") := "UTR5"]
    protein.introns[UTR3.introns,
        on = c("seqnames", "start", "end", "strand"),
            c("intron_type") := "UTR3"]    
    protein.introns[CDS.introns, 
        on = c("seqnames", "start", "end", "strand"),
            c("intron_type") := "CDS"]
    
    NMD.Table = DetermineNMD(Exons.tr, protein.introns, genome, 50)
    NMD.Table[protein.introns, on = "intron_id", 
        c("intron_type") := get("i.intron_type")]
    
    write.fst(NMD.Table, file.path(reference_path, "fst", "IR.NMD.fst"))
}

################################################################################
.gen_splice <- function(reference_path, genome) {

    message("Annotating Splice Events\n")

    GeneOrder = as.data.table(
        read.fst(file.path(reference_path,"fst","Genes.fst"))
    )
    setorder(GeneOrder, seqnames, start, end, strand)
    candidate.introns = as.data.table(
        read.fst(file.path(reference_path,"fst","junctions.fst"))
    )
    introns.skipcoord = copy(candidate.introns)
    setorderv(introns.skipcoord, c("gene_id", "transcript_name", "intron_number"))
    
    introns.skipcoord[get("strand") == "+", 
        c("skip_coord") := ifelse(
            get("intron_number") == max(get("intron_number")), NA, 
            paste0(get("seqnames"),":",get("intron_start"),
                "-", data.table::shift(get("intron_end"), 1, NA, "lead"),
                "/",get("strand"))),
        by = "transcript_id"]
    introns.skipcoord[get("strand") == "-", 
        c("skip_coord") := ifelse(
            get("intron_number") == max(get("intron_number")), NA, 
            paste0(get("seqnames"),":",
                data.table::shift(get("intron_start"), 1, NA, "lead"),
                "-", get("intron_end"),"/",get("strand"))), 
        by = "transcript_id"]
    introns.skipcoord[, 
        c("skip_coord_2") := data.table::shift(get("skip_coord"), 1, NA, "lag")]

    introns.skippedJn = introns.skipcoord[get("skip_coord") %in% get("Event"),
        c("gene_id","gene_name","skip_coord")]
    introns.skippedJn = unique(introns.skippedJn)
 
    chrOrder = names(seqinfo(genome))
 
    message("Annotating Mutually-Exclusive-Exon Splice Events...",
        appendLF = FALSE)

    introns_search_MXE = introns.skipcoord[introns.skipcoord[,
        .I[get("intron_number") < max(get("intron_number"))], 
            by = "transcript_id"]$V1]
    introns_search_MXE = introns_search_MXE[introns_search_MXE[
        ,.N,by = c("gene_id", "skip_coord")],
        on = c("gene_id", "skip_coord"), c("N") := get("i.N")]
    introns_search_MXE = introns_search_MXE[get("N") > 1]
    introns_search_MXE_pos = introns_search_MXE[strand == "+"]
    setorderv(introns_search_MXE_pos, c("seqnames", "intron_start", "intron_end"))
    introns_search_MXE_neg = introns_search_MXE[strand == "-"]
    setorderv(introns_search_MXE_neg, c("seqnames", "intron_end", "intron_start"), 
        order = c(1,1,-1))
    introns_search_MXE = rbindlist(
        list(introns_search_MXE_pos, introns_search_MXE_neg)
    )
    
    introns_search_MXE = introns_search_MXE[, 
        c("skip_coord", "gene_id", "Event", "transcript_id",
        "transcript_name", "intron_number")]
    setnames(introns_search_MXE, old = "Event", new = "Event1")
    
    introns_search_MXE2 = introns.skipcoord[,
        c("skip_coord_2","gene_id","Event","transcript_id","transcript_name")]
    setnames(introns_search_MXE2, 
        old = c("skip_coord_2","Event"), 
            new = c("skip_coord", "Event2"))
    
    introns_search_MXE[introns_search_MXE2, 
        on = c("gene_id","transcript_id","transcript_name","skip_coord"),
        c("Event2") := get("i.Event2")]
    
    introns_search_MXE = unique(introns_search_MXE, 
        by= c("gene_id","skip_coord","Event1"))
    introns_search_MXE = unique(introns_search_MXE, 
        by= c("gene_id","skip_coord","Event2"))
    introns_search_MXE = introns_search_MXE[, if(.N>1) .SD,
        by = c("gene_id","skip_coord")]
    
    if(nrow(introns_search_MXE) > 0) {
        introns_found_MXE = introns_search_MXE[ , 
            {
            edge1 = rep(seq_len(.N), (.N:1) - 1L)
            i = 2L:(.N * (.N - 1L) / 2L + 1L)
                o = cumsum(c(0, (.N-2L):1))
            edge2 = i - o[edge1]
            .(
                gene_id = get("gene_id")[edge1], 
                gene_id_b = get("gene_id")[edge2],
                Event1a = get("Event1")[edge1], 
                Event1b = get("Event1")[edge2],
                Event2a = get("Event2")[edge1], 
                Event2b = get("Event2")[edge2],
                transcript_id_a = get("transcript_id")[edge1],
                transcript_id_b = get("transcript_id")[edge2],
                transcript_name_a = get("transcript_name")[edge1],
                transcript_name_b = get("transcript_name")[edge2],
                intron_number_a = get("intron_number")[edge1],
                intron_number_b = get("intron_number")[edge2]
            )
        }, by = "skip_coord"]

        introns_found_MXE[, 
            c("gene_id") := factor(get("gene_id"),GeneOrder$gene_id,ordered=TRUE)]
        setorderv(introns_found_MXE, c("gene_id", "transcript_name_a"))
        introns_found_MXE[, 
            c("EventName") := paste0("MXE:", get("transcript_name_a"), "-exon",
                (1 + get("intron_number_a")),";",
                get("transcript_name_b"),"-exon",(1 + get("intron_number_b")))
        ]
        introns_found_MXE[, c("EventID") := paste0("MXE#", seq_len(.N))]
        setnames(introns_found_MXE, 
            old = "skip_coord", new = "EventRegion")
        introns_found_MXE[, c("EventType") := "MXE"]
        introns_found_MXE = introns_found_MXE[, 
            c(
                "EventType","EventID","EventName","Event1a","Event1b",
                "Event2a","Event2b", "gene_id","gene_id_b","EventRegion",
                "transcript_id_a","transcript_name_a","intron_number_a",
                "transcript_id_b","transcript_name_b","intron_number_b"
            )
        ]

        introns_found_MXE = unique(introns_found_MXE, 
            by = c("Event1a", "Event1b", "Event2a", "Event2b"))
    } else {
        introns_found_MXE = c()
    }
    message("done\n")
    gc() 
    
################################################################################
# annotate skipped junctions with two included junctions
    message("Annotating Skipped-Exon Splice Events...", appendLF = FALSE)

    introns_found_SE = introns.skippedJn[,"skip_coord"]
    introns_search_SE = candidate.introns[,
        c("gene_id","Event","transcript_id", 
            "transcript_name","intron_number")
    ]
    setnames(introns_search_SE, 
        old = c("Event", "transcript_id", "transcript_name", "intron_number"),
        new = c("skip_coord", "skip_transcript_id", "skip_transcript_name", 
            "skip_intron_number"))
    introns_found_SE[introns_search_SE, on = "skip_coord", 
        c("gene_id_b", "skip_transcript_id",
            "skip_transcript_name", "skip_intron_number") :=
        list(get("i.gene_id"), get("i.skip_transcript_id"),
            get("i.skip_transcript_name"), get("i.skip_intron_number"))]
    introns_found_SE = unique(introns_found_SE,
        by = c("gene_id_b","skip_coord"))    

    introns_search_SE2 = introns.skipcoord[,
        c("skip_coord","gene_id","Event","transcript_id","transcript_name",
            "intron_number")]
    introns_found_SE[introns_search_SE2, on = "skip_coord",
        c("gene_id", "inc_coord_upst", "inc_transcript_id",
            "inc_transcript_name", "inc_intron_number") :=
        list(get("i.gene_id"), get("i.Event"), get("i.transcript_id"),
            get("i.transcript_name"), get("i.intron_number"))]

    introns_search_SE3 = introns.skipcoord[,
        c("skip_coord_2","gene_id","Event",
            "transcript_id","transcript_name")]
    setnames(introns_search_SE3, 
        old = c("skip_coord_2", "transcript_id"),
        new = c("skip_coord", "inc_transcript_id"))
    introns_found_SE[introns_search_SE3, 
        on = c("skip_coord", "inc_transcript_id"),
        c("inc_coord_downst") := get("i.Event")]

    introns_found_SE = unique(introns_found_SE, 
        by = c("gene_id","skip_coord",
            "inc_transcript_id", "inc_transcript_name"))
    introns_found_SE[, 
        c("gene_id") := factor(get("gene_id"), GeneOrder$gene_id, ordered = TRUE)]
    setorderv(introns_found_SE, c("gene_id", "inc_transcript_name"))
    introns_found_SE[, c("EventName") := paste0(
            "SE:",get("inc_transcript_name"),"-exon",(1 + get("inc_intron_number")),";",
            get("skip_transcript_name"),"-int",get("skip_intron_number")
            )]
    introns_found_SE[, c("EventID") := paste0("SE#",seq_len(.N))]
    introns_found_SE[, c("EventType") := "SE"]
    introns_found_SE[, c("Event2b") := NA]
    introns_found_SE[, c("EventRegion") := get("skip_coord")]
    introns_found_SE = introns_found_SE[, 
        c(
            "EventType","EventID","EventName","inc_coord_upst",
            "skip_coord","inc_coord_downst","Event2b",
            "gene_id","gene_id_b", "EventRegion",
            "inc_transcript_id","inc_transcript_name","inc_intron_number",
            "skip_transcript_id","skip_transcript_name","skip_intron_number"
        )
    ]
    setnames(introns_found_SE, 
        old = c("inc_coord_upst", "inc_coord_downst", "skip_coord"),
        new = c("Event1a", "Event2a", "Event1b"))
    setnames(introns_found_SE, 
        old = c("inc_transcript_id", "inc_transcript_name",
            "skip_transcript_id","skip_transcript_name"),
        new = c("transcript_id_a", "transcript_name_a",
            "transcript_id_b","transcript_name_b"))
    setnames(introns_found_SE, 
        new = c("intron_number_a","intron_number_b"),
        old = c("inc_intron_number", "skip_intron_number")
    )

    message("done\n")
    gc()

################################################################################
    message("Annotating Alternate First / Last Exon Splice Events...",
        appendLF = FALSE)

    # AFE/ALE

    introns_search_AFE = candidate.introns[get("intron_number") == 1]
    introns_search_AFE[,
        c("seqnames") := factor(get("seqnames"), chrOrder, ordered = TRUE)]

    introns_search_AFE_pos = introns_search_AFE[get("strand") == "+"]
    setorderv(introns_search_AFE_pos, 
        c("seqnames", "intron_end", "intron_start"), 
        order = c(1,1,-1))
    introns_search_AFE_pos = introns_search_AFE_pos[,
        c("seqnames", "intron_end", "strand", "Event", "gene_id", 
            "transcript_id", "transcript_name", "intron_number")]
    setnames(introns_search_AFE_pos, old = "intron_end", new = "intron_coord")

    introns_search_AFE_neg = introns_search_AFE[get("strand") == "-"]
    setorderv(introns_search_AFE_neg, c("seqnames", "intron_start", "intron_end"))
    introns_search_AFE_neg = introns_search_AFE_neg[,
        c("seqnames", "intron_start", "strand", "Event", "gene_id", 
            "transcript_id", "transcript_name", "intron_number")]
    setnames(introns_search_AFE_neg, old = "intron_start", new = "intron_coord")

    introns_search_AFE = rbindlist(
        list(introns_search_AFE_pos, introns_search_AFE_neg))
    introns_search_AFE = unique(introns_search_AFE, by = "Event")

    introns_search_ALE = candidate.introns[candidate.introns[,
            .I[get("intron_number") == max(get("intron_number"))], 
            by = "transcript_id"]$V1]
    introns_search_ALE[, 
        c("seqnames") := factor(get("seqnames"), chrOrder, ordered = TRUE)]

    introns_search_ALE_pos = introns_search_ALE[get("strand") == "+"]
    setorderv(introns_search_ALE_pos, c("seqnames", "intron_start", "intron_end"))
    introns_search_ALE_pos = introns_search_ALE_pos[,
        c("seqnames", "intron_start", "strand", "Event", "gene_id", 
            "transcript_id", "transcript_name", "intron_number")]
    setnames(introns_search_ALE_pos, 
        old = "intron_start", new = "intron_coord")

    introns_search_ALE_neg = introns_search_ALE[get("strand") == "-"]
    setorderv(introns_search_ALE_neg, c("seqnames", "intron_end", "intron_start"),
        order = c(1,1,-1))
    introns_search_ALE_neg = introns_search_ALE_neg[,
        c("seqnames", "intron_end", "strand", "Event", "gene_id", 
            "transcript_id", "transcript_name", "intron_number")]
    setnames(introns_search_ALE_neg, old = "intron_end", new = "intron_coord")

    introns_search_ALE = rbindlist(
        list(introns_search_ALE_pos, introns_search_ALE_neg))
    introns_search_ALE = unique(introns_search_ALE, by = "Event")

    introns_found_AFE = introns_search_AFE[ , 
            {    
        edge1 = rep(seq_len(.N), (.N:1) - 1L)
        i = 2L:(.N * (.N - 1L) / 2L + 1L)
            o = cumsum(c(0, (.N-2L):1))
        edge2 = i - o[edge1]
        .(
            gene_id = get("gene_id")[edge1], 
            gene_id_b = get("gene_id")[edge2],
            Event1a = get("Event")[edge1], 
            Event1b = get("Event")[edge2],
            Event2a = NA, Event2b = NA, EventRegion = get("Event")[edge2],
            transcript_id_a = get("transcript_id")[edge1],
            transcript_id_b = get("transcript_id")[edge2],
            transcript_name_a = get("transcript_name")[edge1],
            transcript_name_b = get("transcript_name")[edge2],
            intron_number_a = get("intron_number")[edge1],
            intron_number_b = get("intron_number")[edge2]
        )
    }, by = c("seqnames", "intron_coord")]
    introns_found_AFE = introns_found_AFE[!is.na(get("gene_id"))]
    
    introns_found_ALE = introns_search_ALE[ , 
            {        
        edge1 = rep(seq_len(.N), (.N:1) - 1L)
        i = 2L:(.N * (.N - 1L) / 2L + 1L)
            o = cumsum(c(0, (.N-2L):1))
        edge2 = i - o[edge1]
        .(
            gene_id = get("gene_id")[edge1], 
            gene_id_b = get("gene_id")[edge2],
            Event1a = get("Event")[edge1], 
            Event1b = get("Event")[edge2],
            Event2a = NA, Event2b = NA, EventRegion = get("Event")[edge2],
            transcript_id_a = get("transcript_id")[edge1],
            transcript_id_b = get("transcript_id")[edge2],
            transcript_name_a = get("transcript_name")[edge1],
            transcript_name_b = get("transcript_name")[edge2],
            intron_number_a = get("intron_number")[edge1],
            intron_number_b = get("intron_number")[edge2]
        )
    }, by = c("seqnames", "intron_coord")]
    introns_found_ALE = introns_found_ALE[!is.na(get("gene_id"))]

################################################################################
    introns_found_AFE = unique(introns_found_AFE, by = c("Event1a", "Event1b"))
    introns_found_AFE = introns_found_AFE[, 
        c("gene_id") := factor(get("gene_id"), GeneOrder$gene_id, ordered = TRUE)]
    setorderv(introns_found_AFE, c("gene_id", "transcript_name_a"))
    introns_found_AFE = introns_found_AFE[, 
        c("EventName") := paste0("AFE:",get("transcript_name_a"),"-exon",
            get("intron_number_a"), ";",
            get("transcript_name_b"),"-exon",get("intron_number_b"))]
    introns_found_AFE = introns_found_AFE[, c("EventType") := "AFE"]
    introns_found_AFE = introns_found_AFE[, c("EventRegion") := get("Event1b")]
    introns_found_AFE[, c("EventID") := paste0("AFE#", seq_len(.N))]
    introns_found_AFE = introns_found_AFE[, 
        c("EventType", "EventID", "EventName",
        "Event1a", "Event1b", "Event2a", "Event2b",
        "gene_id", "gene_id_b", "EventRegion",
        "transcript_id_a", "transcript_name_a", "intron_number_a",
        "transcript_id_b", "transcript_name_b", "intron_number_b")]
    
    introns_found_ALE = unique(introns_found_ALE, by = c("Event1a", "Event1b"))
    introns_found_ALE = introns_found_ALE[, 
        c("gene_id") := factor(get("gene_id"), GeneOrder$gene_id, ordered = TRUE)]
    setorderv(introns_found_ALE, c("gene_id", "transcript_name_a"))
    introns_found_ALE = introns_found_ALE[, 
        c("EventName") := paste0("ALE:",get("transcript_name_a"),"-exon",
            get("intron_number_a"),";",
            get("transcript_name_b"),"-exon",get("intron_number_b"))]
    introns_found_ALE = introns_found_ALE[, c("EventType") := "ALE"]
    introns_found_ALE = introns_found_ALE[, c("EventRegion") := get("Event1b")]
    introns_found_ALE[, c("EventID") := paste0("ALE#", seq_len(.N))]
    introns_found_ALE = introns_found_ALE[,
        c("EventType", "EventID", "EventName",
        "Event1a", "Event1b", "Event2a", "Event2b",
        "gene_id", "gene_id_b", "EventRegion",
        "transcript_id_a", "transcript_name_a", "intron_number_a",
        "transcript_id_b", "transcript_name_b", "intron_number_b")]

    message("done\n")
    gc()
################################################################################
    message("Annotating Alternate 5' / 3' Splice Site Splice Events...",
        appendLF = FALSE)

    candidate.introns.ASS = candidate.introns[
        !is.na(get("exon_group_stranded_upstream")) &
        !is.na(get("exon_group_stranded_downstream"))]
    
    setnames(candidate.introns.ASS, 
        old = c("exon_group_stranded_upstream",
            "exon_group_stranded_downstream"),
        new = c("exon_groups_start","exon_groups_end"))
    
    introns_search_A5SS = copy(candidate.introns.ASS)
    introns_search_A5SS[, 
        c("seqnames") := factor(get("seqnames"), chrOrder, ordered = TRUE)]

    introns_search_A5SS_pos = introns_search_A5SS[get("strand") == "+"]
    setorderv(introns_search_A5SS_pos, c("seqnames", "intron_end", "intron_start"),
        order = c(1,1,-1))
    introns_search_A5SS_pos = introns_search_A5SS_pos[,
        c("seqnames", "intron_end", "strand", "Event", "gene_id", 
            "transcript_id", "transcript_name", "intron_number",
            "exon_groups_start","exon_groups_end")]
    setnames(introns_search_A5SS_pos, 
        old = "intron_end", new = "intron_coord")

    introns_search_A5SS_neg = introns_search_A5SS[get("strand") == "-"]
    setorderv(introns_search_A5SS_neg, c("seqnames", "intron_start", "intron_end"))
    introns_search_A5SS_neg = introns_search_A5SS_neg[,
        c("seqnames", "intron_start", "strand", "Event", "gene_id", 
            "transcript_id", "transcript_name", "intron_number",
            "exon_groups_start","exon_groups_end")]
    setnames(introns_search_A5SS_neg, 
        old = "intron_start", new = "intron_coord")

    introns_search_A5SS = rbindlist(
        list(introns_search_A5SS_pos, introns_search_A5SS_neg))
    introns_search_A5SS = unique(introns_search_A5SS, by = "Event")

    introns_search_A3SS = copy(candidate.introns.ASS)
    introns_search_A3SS[, 
        c("seqnames") := factor(get("seqnames"), chrOrder, ordered = TRUE)]

    introns_search_A3SS_pos = introns_search_A3SS[get("strand") == "+"]
    setorderv(introns_search_A3SS_pos, c("seqnames", "intron_start", "intron_end"))
    introns_search_A3SS_pos = introns_search_A3SS_pos[,
        c("seqnames", "intron_start", "strand", "Event", "gene_id", 
            "transcript_id", "transcript_name", "intron_number",
            "exon_groups_start","exon_groups_end")]
    setnames(introns_search_A3SS_pos, 
        old = "intron_start", new = "intron_coord")

    introns_search_A3SS_neg = introns_search_A3SS[get("strand") == "-"]
    setorderv(introns_search_A3SS_neg, c("seqnames", "intron_end", "intron_start"),
        order = c(1,1,-1))
    introns_search_A3SS_neg = introns_search_A3SS_neg[,
        c("seqnames", "intron_end", "strand", "Event", "gene_id", 
            "transcript_id", "transcript_name", "intron_number",
            "exon_groups_start","exon_groups_end")]
    setnames(introns_search_A3SS_neg, 
        old = "intron_end", new = "intron_coord")

    introns_search_A3SS = rbindlist(
        list(introns_search_A3SS_pos, introns_search_A3SS_neg))
    introns_search_A3SS = unique(introns_search_A3SS, by = "Event")

################################################################################
    introns_found_A5SS = introns_search_A5SS[ , 
        {
        edge1 = rep(seq_len(.N), (.N:1) - 1L)
        i = 2L:(.N * (.N - 1L) / 2L + 1L)
            o = cumsum(c(0, (.N-2L):1))
        edge2 = i - o[edge1]
        .(
            gene_id = get("gene_id")[edge1], 
            gene_id_b = get("gene_id")[edge2],
            Event1a = get("Event")[edge1], 
            Event1b = get("Event")[edge2],
            Event2a = NA, Event2b = NA, EventRegion = get("Event")[edge2],
            transcript_id_a = get("transcript_id")[edge1],
            transcript_id_b = get("transcript_id")[edge2],
            transcript_name_a = get("transcript_name")[edge1],
            transcript_name_b = get("transcript_name")[edge2],
            intron_number_a = get("intron_number")[edge1],
            intron_number_b = get("intron_number")[edge2],
            exon_groups_start_a = get("exon_groups_start")[edge1],
            exon_groups_start_b = get("exon_groups_start")[edge2],
            exon_groups_end_a = get("exon_groups_end")[edge1],
            exon_groups_end_b = get("exon_groups_end")[edge2]
        )
        }, by = "intron_coord"]
    introns_found_A5SS = introns_found_A5SS[!is.na(get("gene_id"))]
    
    introns_found_A3SS = introns_search_A3SS[ , 
        {    
        edge1 = rep(seq_len(.N), (.N:1) - 1L)
        i = 2L:(.N * (.N - 1L) / 2L + 1L)
            o = cumsum(c(0, (.N-2L):1))
        edge2 = i - o[edge1]
        .(
            gene_id = get("gene_id")[edge1], 
            gene_id_b = get("gene_id")[edge2],
            Event1a = get("Event")[edge1], 
            Event1b = get("Event")[edge2],
            Event2a = NA, Event2b = NA, EventRegion = get("Event")[edge2],
            transcript_id_a = get("transcript_id")[edge1],
            transcript_id_b = get("transcript_id")[edge2],
            transcript_name_a = get("transcript_name")[edge1],
            transcript_name_b = get("transcript_name")[edge2],
            intron_number_a = get("intron_number")[edge1],
            intron_number_b = get("intron_number")[edge2],
            exon_groups_start_a = get("exon_groups_start")[edge1],
            exon_groups_start_b = get("exon_groups_start")[edge2],
            exon_groups_end_a = get("exon_groups_end")[edge1],
            exon_groups_end_b = get("exon_groups_end")[edge2]
        )
        }, by = "intron_coord"]
    introns_found_A3SS = introns_found_A3SS[!is.na(get("gene_id"))]

    introns_found_A5SS = unique(introns_found_A5SS,
        by = c("Event1a", "Event1b"))
    # filter by same exon group starts and ends:
       introns_found_A5SS = introns_found_A5SS[
        get("exon_groups_start_a") == get("exon_groups_start_b")]
       introns_found_A5SS = introns_found_A5SS[
        get("exon_groups_end_a") == get("exon_groups_end_b")]

    introns_found_A5SS = introns_found_A5SS[, 
        c("gene_id") := factor(get("gene_id"), GeneOrder$gene_id, ordered = TRUE)]
    setorderv(introns_found_A5SS, c("gene_id", "transcript_name_a"))
    introns_found_A5SS = introns_found_A5SS[, 
        c("EventName") := paste0("A5SS:",get("transcript_name_a"),"-exon",
            get("intron_number_a"),";",
            get("transcript_name_b"),"-exon",get("intron_number_b"))]
    introns_found_A5SS = introns_found_A5SS[, c("EventType") := "A5SS"]
    introns_found_A5SS = introns_found_A5SS[, c("EventRegion") := get("Event1b")]
    introns_found_A5SS = introns_found_A5SS[!introns_found_AFE,
        on = c("Event1a", "Event1b")]
    introns_found_A5SS[, c("EventID") := paste0("A5SS#", seq_len(.N))]
    introns_found_A5SS = introns_found_A5SS[,
        c("EventType", "EventID", "EventName",
            "Event1a", "Event1b", "Event2a", "Event2b",
            "gene_id", "gene_id_b", "EventRegion",
            "transcript_id_a", "transcript_name_a", "intron_number_a",
            "transcript_id_b", "transcript_name_b", "intron_number_b")]

    introns_found_A3SS = unique(introns_found_A3SS,
        by = c("Event1a", "Event1b"))
    # filter by same exon group starts and ends:
       introns_found_A3SS = introns_found_A3SS[
        get("exon_groups_start_a") == get("exon_groups_start_b")]
       introns_found_A3SS = introns_found_A3SS[
        get("exon_groups_end_a") == get("exon_groups_end_b")]
    introns_found_A3SS = introns_found_A3SS[,
        c("gene_id") := factor(get("gene_id"), GeneOrder$gene_id, ordered = TRUE)]
    setorderv(introns_found_A3SS, c("gene_id", "transcript_name_a"))
    introns_found_A3SS = introns_found_A3SS[,
        c("EventName") := paste0("A3SS:",get("transcript_name_a"),"-exon",
            get("intron_number_a"),";",
            get("transcript_name_b"),"-exon",get("intron_number_b"))]
    introns_found_A3SS = introns_found_A3SS[, c("EventType") := "A3SS"]
    introns_found_A3SS = introns_found_A3SS[, c("EventRegion") := get("Event1b")]
    introns_found_A3SS = introns_found_A3SS[!introns_found_ALE, 
        on = c("Event1a", "Event1b")]
    introns_found_A3SS[, c("EventID") := paste0("A3SS#", seq_len(.N))]
    introns_found_A3SS = introns_found_A3SS[,
        c("EventType", "EventID", "EventName",
            "Event1a", "Event1b", "Event2a", "Event2b",
            "gene_id", "gene_id_b", "EventRegion",
            "transcript_id_a", "transcript_name_a", "intron_number_a",
            "transcript_id_b", "transcript_name_b", "intron_number_b")]
    

################################################################################
#   Filter for valid splicing

    is_valid_splice_type <- function(x) !is.null(x) && nrow(x) > 0
    
    tmp_AS = list(introns_found_MXE, introns_found_SE,
            introns_found_AFE, introns_found_ALE,
            introns_found_A5SS, introns_found_A3SS)
    tmp_AS <- base::Filter(is_valid_splice_type, tmp_AS)
    AS_Table = rbindlist(tmp_AS)    
    
################################################################################
    if(nrow(AS_Table) > 0) {
        candidate.introns.order = copy(candidate.introns)
        if(!("transcript_support_level" %in% colnames(candidate.introns))) {
          candidate.introns.order[, c("transcript_support_level") := "NA"]
        }
        candidate.introns.order[, 
            c("is_protein_coding") := !is.na(get("protein_id"))]
        candidate.introns.order[, by = "transcript_id",
            c("is_last_intron") := 
                (get("intron_number") == max(get("intron_number")))]
        
        AS_Table_SEarch.a = AS_Table[,
            c("EventType", "EventID", "Event1a", "Event2a")]
        AS_Table_SEarch.a[,c("Event") := get("Event1a")]
        AS_Table_SEarch.a = candidate.introns.order[AS_Table_SEarch.a,
            on = "Event", 
            c("EventType","EventID", "Event1a", "Event2a", "transcript_id",
                "transcript_support_level", "is_protein_coding",
                "is_last_intron", "intron_number")]
        setnames(AS_Table_SEarch.a, "intron_number", "in_1a")
        AS_Table_SEarch.a = 
            AS_Table_SEarch.a[get("EventType") !=  "AFE" | get("in_1a") == 1]
        AS_Table_SEarch.a = 
            AS_Table_SEarch.a[get("EventType") !=  "ALE" | get("is_last_intron")]
        AS_Table_SEarch.a[,c("Event") := get("Event2a")]
        AS_Table_SEarch.a[is.na(get("Event")), c("Event") := get("Event1a")]
        AS_Table_SEarch.a = candidate.introns.order[AS_Table_SEarch.a, 
            on = c("Event", "transcript_id", "transcript_support_level"),
            c("EventType","EventID", "Event1a", "Event2a", "transcript_id",
                "transcript_support_level", "is_protein_coding",
                "is_last_intron","in_1a", "intron_number")]
        AS_Table_SEarch.a = AS_Table_SEarch.a[!is.na(get("intron_number"))]
        setnames(AS_Table_SEarch.a, "intron_number", "in_2a")
        
        AS_Table_SEarch.b = AS_Table[,
            c("EventType", "EventID", "Event1b", "Event2b")]
        AS_Table_SEarch.b[,c("Event") := get("Event1b")]
        AS_Table_SEarch.b = candidate.introns.order[AS_Table_SEarch.b,
            on = "Event", 
            c("EventType","EventID", "Event1b", "Event2b", "transcript_id",
                "transcript_support_level", "is_protein_coding",
                "is_last_intron","intron_number")]
        setnames(AS_Table_SEarch.b, "intron_number", "in_1b")
        AS_Table_SEarch.b = 
            AS_Table_SEarch.b[get("EventType") !=  "AFE" | get("in_1b") == 1]
        AS_Table_SEarch.b = 
            AS_Table_SEarch.b[get("EventType") !=  "ALE" | get("is_last_intron")]
        AS_Table_SEarch.b[,c("Event") := get("Event2b")]
        AS_Table_SEarch.b[is.na(get("Event")),c("Event") := get("Event1b")]
        AS_Table_SEarch.b = candidate.introns.order[AS_Table_SEarch.b, 
            on = c("Event", "transcript_id", "transcript_support_level"),
            c("EventType","EventID", "Event1b", "Event2b", "transcript_id",
                "transcript_support_level", "is_protein_coding",
                "is_last_intron", "in_1b", "intron_number")]
        AS_Table_SEarch.b = AS_Table_SEarch.b[!is.na(get("intron_number"))]
        setnames(AS_Table_SEarch.b, "intron_number", "in_2b")

        AS_Table_SEarch.a[candidate.introns.order, 
            on = "transcript_id", 
            c("transcript_name") := get("i.transcript_name")]
        AS_Table_SEarch.b[candidate.introns.order, 
            on = "transcript_id", 
            c("transcript_name") := get("i.transcript_name")]
        setorderv(AS_Table_SEarch.a, 
            c("transcript_support_level", "is_protein_coding", "transcript_name"),
            order = c(1,-1,1))
        setorderv(AS_Table_SEarch.b, 
            c("transcript_support_level", "is_protein_coding", "transcript_name"),
            order = c(1,-1,1))
        AS_Table.find.a = unique(AS_Table_SEarch.a, by = "EventID")
        AS_Table.find.a = AS_Table.find.a[AS_Table[, "EventID"], on = "EventID"]
        AS_Table.find.b = unique(AS_Table_SEarch.b, by = "EventID")
        AS_Table.find.b = AS_Table.find.b[AS_Table[, "EventID"], on = "EventID"]
################################################################################        
        AS_Table$transcript_id_a = AS_Table.find.a$transcript_id
        AS_Table$transcript_name_a = AS_Table.find.a$transcript_name
        AS_Table$intron_number_a = AS_Table.find.a$in_1a
        AS_Table$transcript_id_b = AS_Table.find.b$transcript_id
        AS_Table$transcript_name_b = AS_Table.find.b$transcript_name
        AS_Table$intron_number_b = AS_Table.find.b$in_1b
        
        AS_Table[get("EventType") == "MXE", 
            c("EventName") := paste0("MXE:", get("transcript_name_a"),"-exon",
                as.character(as.numeric(get("intron_number_a")) + 1), ";", 
                get("transcript_name_b"),"-exon",
                as.character(as.numeric(get("intron_number_b")) + 1)
            )
        ]
        AS_Table[get("EventType") == "SE", 
            c("EventName") := paste0("SE:", get("transcript_name_a"),"-exon",
                as.character(as.numeric(get("intron_number_a")) + 1), ";",
                get("transcript_name_b"),"-int",
                as.character(as.numeric(get("intron_number_b")))
            )
        ]
        AS_Table[get("EventType") == "AFE", 
            c("EventName") := paste0("AFE:", get("transcript_name_a"),"-exon1;", 
            get("transcript_name_b"),"-exon1")]
        AS_Table[get("EventType") == "ALE", 
            c("EventName") := paste0("ALE:", get("transcript_name_a"), "-exon", 
                as.character(as.numeric(get("intron_number_a")) + 1), ";", 
                get("transcript_name_b"), "-exon",
                as.character(as.numeric(get("intron_number_b")) + 1)
            )
        ]
        AS_Table[get("EventType") == "A5SS", 
            c("EventName") := paste0("A5SS:", get("transcript_name_a"),"-exon", 
                as.character(as.numeric(get("intron_number_a"))), ";", 
                get("transcript_name_b"),"-exon",
                as.character(as.numeric(get("intron_number_b")))
            )
        ]
        AS_Table[get("EventType") == "A3SS", 
            c("EventName") := paste0("A3SS:", get("transcript_name_a"),"-exon", 
                as.character(as.numeric(get("intron_number_a") + 1)), ";",
                get("transcript_name_b"),"-exon",
                as.character(as.numeric(get("intron_number_b") + 1))
            )
        ]
        write.fst(as.data.frame(AS_Table), file.path(reference_path,"fst","Splice.fst"))
        
        setnames(AS_Table_SEarch.a, 
            old = c("Event1a", "Event2a", "in_1a", "in_2a"),
            new = c("Event1", "Event2", "in_1", "in_2"))
        AS_Table_SEarch.a[, c("isoform") := "A"]
        setnames(AS_Table_SEarch.b,
            old = c("Event1b", "Event2b", "in_1b", "in_2b"),
            new = c("Event1", "Event2", "in_1", "in_2"))
        AS_Table_SEarch.b[, c("isoform") := "B"]
        
        write.fst(as.data.frame(rbind(AS_Table_SEarch.a, AS_Table_SEarch.b)), 
          file.path(reference_path,"fst","Splice.options.fst"))
        message("done\n")
    } else {
        message("no splice events found\n")
    }
    gc()

}

################################################################################
.gen_splice_proteins <- function(reference_path, genome) {
    message("Translating Alternate Splice Peptides...", appendLF = FALSE)

    AS_Table <- as.data.table(
        read.fst(file.path(reference_path,"fst","Splice.fst"))
    )
    Proteins_Splice = as.data.table(
        read.fst(file.path(reference_path,"fst","Proteins.fst"))
    )

    AS_Table.Extended = copy(AS_Table)
    
    Proteins_Splice$exon_number = as.numeric(Proteins_Splice$exon_number)
    # make phase easier for me to understand
    Proteins_Splice[, c("phase") := -get("phase") %% 3]
    # Upstream applicable for MXE, SE, ALE, A3SS
    Upstream = AS_Table[get("EventType") %in% c("MXE", "SE", "ALE", "A3SS")]

    # Do A
    Upstream_A = Upstream[,
        c("EventID", "transcript_id_a", "intron_number_a")]
    Upstream_A[, c("transcript_id", "exon_number") := 
        list(get("transcript_id_a"), get("intron_number_a"))]
    # left_join with Exons
    Upstream_A = Proteins_Splice[Upstream_A, 
        on = c("transcript_id", "exon_number"), 
        c("EventID", "seqnames", "start", "end", "width", "strand", "phase")]
    Upstream_A_gr = makeGRangesFromDataFrame(as.data.frame(
        na.omit(Upstream_A)), keep.extra.columns = TRUE)
    Upstream_A_seq = getSeq(genome, Upstream_A_gr)
    Upstream_A[!is.na(get("seqnames")),c("seq") := as.character(Upstream_A_seq)]
    # Trim sequence by phase
    seq = substr(Upstream_A$seq[!is.na(Upstream_A$seqnames)],
        1 + (3 - Upstream_A$phase[!is.na(Upstream_A$seqnames)]) %% 3,
        nchar(Upstream_A$seq[!is.na(Upstream_A$seqnames)]))        
    # trim last n bases
    seq = substr(seq, 1, nchar(seq) - (nchar(seq) %% 3))
    # translate
    prot = Biostrings::translate(as(seq, "DNAStringSet"))
    Upstream_A[!is.na(get("seqnames")), c("AA_seq") := as.character(prot)]
    AS_Table.Extended[get("EventType") %in% c("MXE", "SE", "ALE", "A3SS"),
        c("AA_upstr.A") := Upstream_A$AA_seq]

    # repeat for B:
    Upstream_B = Upstream[,
        c("EventID", "transcript_id_b", "intron_number_b")]
    Upstream_B[, c("transcript_id", "exon_number") :=
        list(get("transcript_id_b"), get("intron_number_b"))]
    # left_join with Exons
    Upstream_B = Proteins_Splice[Upstream_B, 
        on = c("transcript_id", "exon_number"), 
        c("EventID", "seqnames", "start", "end", "width", "strand", "phase")]
    Upstream_B_gr = makeGRangesFromDataFrame(as.data.frame(
        na.omit(Upstream_B)), keep.extra.columns = TRUE)
    Upstream_B_seq = getSeq(genome, Upstream_B_gr)
    Upstream_B[!is.na(get("seqnames")),c("seq") := as.character(Upstream_B_seq)]
    # Trim sequence by phase
    seq = substr(Upstream_B$seq[!is.na(Upstream_B$seqnames)],
        1 + (3 - Upstream_B$phase[!is.na(Upstream_B$seqnames)]) %% 3,
        nchar(Upstream_B$seq[!is.na(Upstream_B$seqnames)]))        
    # trim last n bases
    seq = substr(seq, 1, nchar(seq) - (nchar(seq) %% 3))
    # translate
    prot = Biostrings::translate(as(seq, "DNAStringSet"))
    Upstream_B[!is.na(get("seqnames")), c("AA_seq") := as.character(prot)]
    AS_Table.Extended[get("EventType") %in% c("MXE", "SE", "ALE", "A3SS"),
        c("AA_upstr.B") := Upstream_B$AA_seq]
        
################################################################################    
    # Do downstream seq before casette:
    Downstream = AS_Table[get("EventType") %in% c("MXE", "SE", "AFE", "A5SS")]
    # Add EventType as exon_number is conditional on this
    Downstream_A = Downstream[, 
        c("EventType", "EventID", "transcript_id_a", "intron_number_a")]
    Downstream_A[, c("transcript_id", "exon_number") := 
        list(get("transcript_id_a"), get("intron_number_a"))]
    # Modify downstream exon number
    Downstream_A[get("EventType") %in% c("MXE", "SE"), 
       c("exon_number") := get("exon_number") + 2]
    Downstream_A[get("EventType") %in% c("AFE", "A5SS"), 
        c("exon_number") := get("exon_number") + 1]
    # left_join with Exons
    Downstream_A = Proteins_Splice[Downstream_A, 
        on = c("transcript_id", "exon_number"), 
        c("EventID", "seqnames", "start", "end", "width", "strand", "phase")]
    Downstream_A_gr = makeGRangesFromDataFrame(as.data.frame(
        na.omit(Downstream_A)), keep.extra.columns = TRUE)
    Downstream_A_seq = getSeq(genome, Downstream_A_gr)
    Downstream_A[!is.na(get("seqnames")),c("seq") := as.character(Downstream_A_seq)]
    # Trim sequence by phase
    seq = substr(Downstream_A$seq[!is.na(Downstream_A$seqnames)],
        1 + (3 - Downstream_A$phase[!is.na(Downstream_A$seqnames)]) %% 3,
        nchar(Downstream_A$seq[!is.na(Downstream_A$seqnames)]))        
    # trim last n bases
    seq = substr(seq, 1, nchar(seq) - (nchar(seq) %% 3))
    # translate
    prot = Biostrings::translate(as(seq, "DNAStringSet"))
    Downstream_A[!is.na(get("seqnames")), c("AA_seq") := as.character(prot)]
    AS_Table.Extended[get("EventType") %in% c("MXE", "SE", "AFE", "A5SS"),
        c("AA_downstr_A") := Downstream_A$AA_seq]
    # B:
    Downstream_B = Downstream[, 
        c("EventType", "EventID", "transcript_id_b", "intron_number_b")]
    Downstream_B[, c("transcript_id", "exon_number") := 
        list(get("transcript_id_b"), get("intron_number_b"))]
    # Modify downstream exon number: Note SE is different for B
    Downstream_B[get("EventType") %in% c("MXE"), c("exon_number") := get("exon_number") + 2]
    Downstream_B[get("EventType") %in% c("SE", "AFE", "A5SS"), 
        c("exon_number") := get("exon_number") + 1]
    # left_join with Exons
    Downstream_B = Proteins_Splice[Downstream_B, 
        on = c("transcript_id", "exon_number"), 
        c("EventID", "seqnames", "start", "end", "width", "strand", "phase")]
    Downstream_B_gr = makeGRangesFromDataFrame(as.data.frame(
        na.omit(Downstream_B)), keep.extra.columns = TRUE)
    Downstream_B_seq = getSeq(genome, Downstream_B_gr)
    Downstream_B[!is.na(get("seqnames")),c("seq") := as.character(Downstream_B_seq)]
    # Trim sequence by phase
    seq = substr(Downstream_B$seq[!is.na(Downstream_B$seqnames)],
        1 + (3 - Downstream_B$phase[!is.na(Downstream_B$seqnames)]) %% 3,
        nchar(Downstream_B$seq[!is.na(Downstream_B$seqnames)]))        
    # trim last n bases
    seq = substr(seq, 1, nchar(seq) - (nchar(seq) %% 3))
    # translate
    prot = Biostrings::translate(as(seq, "DNAStringSet"))
    Downstream_B[!is.na(get("seqnames")), c("AA_seq") := as.character(prot)]
    AS_Table.Extended[get("EventType") %in% c("MXE", "SE", "AFE", "A5SS"),
        c("AA_downstr_B") := Downstream_B$AA_seq]
        
################################################################################
    # Casette A
    Casette.A = AS_Table[, 
        c("EventType", "EventID", "transcript_id_a", "intron_number_a")]
    Casette.A[, c("transcript_id", "exon_number") := 
        list(get("transcript_id_a"), get("intron_number_a"))]
    Casette.A[get("EventType") %in% c("MXE", "SE", "ALE", "A3SS"), 
        c("exon_number") := get("exon_number") + 1]

    Casette.A = Proteins_Splice[Casette.A, 
        on = c("transcript_id", "exon_number"), 
        c("EventID", "seqnames", "start", "end", "width", "strand", "phase")]
    Casette.A_gr = makeGRangesFromDataFrame(as.data.frame(
        na.omit(Casette.A)), keep.extra.columns = TRUE)
    Casette.A_seq = getSeq(genome, Casette.A_gr)
    Casette.A[!is.na(get("seqnames")),
        c("casette_seq") := as.character(Casette.A_seq)]

    setnames(Casette.A, "phase", "phase_casette")
# Add nucleotides from upstream and downstream
    Casette.A = Upstream_A[Casette.A, on = "EventID", 
        c("EventID", "phase_casette", "casette_seq", "seq")]
    setnames(Casette.A, "seq", "upstr_seq")
    Casette.A = Downstream_A[Casette.A, on = "EventID", 
        c("EventID", "phase_casette", "casette_seq", "upstr_seq", "seq")]
    setnames(Casette.A, "seq", "Downstr_seq")
    
# Construct extended casette sequence:
    Casette.A[, c("casette_seq_extended") := get("casette_seq")]
    # Trim casette_seq_extended if upstream sequence does not exists
    Casette.A[!is.na(get("phase_casette")) & is.na(get("upstr_seq")),
        c("casette_seq_extended") := substr(
            get("casette_seq_extended"), 
            get("phase_casette") + 1, 
            nchar(get("casette_seq_extended"))
        )
    ]    
    Casette.A[!is.na(get("phase_casette")) & get("phase_casette") > 0 & 
            !is.na(get("upstr_seq")), 
        c("casette_seq_extended") := paste0(
            substr(get("upstr_seq"), 
                nchar(get("upstr_seq")) + 1 - get("phase_casette"), 
                nchar(get("upstr_seq"))),
            get("casette_seq_extended")
        )
    ]
    Casette.A[nchar(get("casette_seq_extended")) %% 3 > 0 & !is.na(get("Downstr_seq")), 
        c("casette_seq_extended") := paste0(
            get("casette_seq_extended"),
            substr(get("Downstr_seq"), 1, 3 - (nchar(get("casette_seq_extended")) %% 3))
        )
    ]
# Translate:
    seq = Casette.A$casette_seq_extended[
        !is.na(Casette.A$casette_seq_extended)]
    # trim out-of-phase to be tidy:
    seq = substr(seq, 1, nchar(seq) - (nchar(seq) %% 3))
    prot = Biostrings::translate(as(seq, "DNAStringSet"))
    Casette.A[!is.na(get("casette_seq_extended")), 
        c("AA_seq") := as.character(prot)]
    AS_Table.Extended[, c("AA_casette.A") := Casette.A$AA_seq]
    
################################################################################
    # Casette B
    Casette.B = AS_Table[get("EventType") != "SE", 
        c("EventType", "EventID", "transcript_id_b", "intron_number_b")]
    Casette.B[, c("transcript_id", "exon_number") := 
        list(get("transcript_id_b"), get("intron_number_b"))]
    Casette.B[get("EventType") %in% c("MXE", "ALE", "A3SS"), 
        c("exon_number") := get("exon_number") + 1]

    Casette.B = Proteins_Splice[Casette.B, 
        on = c("transcript_id", "exon_number"), 
        c("EventID", "seqnames", "start", "end", "width", "strand", "phase")]
    Casette.B_gr = makeGRangesFromDataFrame(as.data.frame(
        na.omit(Casette.B)), keep.extra.columns = TRUE)
    Casette.B_seq = getSeq(genome, Casette.B_gr)
    Casette.B[!is.na(get("seqnames")),c("casette_seq") := as.character(Casette.B_seq)]

    setnames(Casette.B, "phase", "phase_casette")
# Add nucleotides from upstream and downstream
    Casette.B = Upstream_B[Casette.B, on = "EventID", 
        c("EventID", "phase_casette", "casette_seq", "seq")]
    setnames(Casette.B, "seq", "upstr_seq")
    Casette.B = Downstream_B[Casette.B, on = "EventID", 
        c("EventID", "phase_casette", "casette_seq", "upstr_seq", "seq")]
    setnames(Casette.B, "seq", "Downstr_seq")
    
# Construct extended casette sequence:
    Casette.B[, c("casette_seq_extended") := get("casette_seq")]
    # Trim casette_seq_extended if upstream sequence does not exists
    Casette.B[!is.na(get("phase_casette")) & is.na(get("upstr_seq")),
        c("casette_seq_extended") := substr(
            get("casette_seq_extended"), get("phase_casette") + 1, 
            nchar(get("casette_seq_extended"))
        )
    ]    
    Casette.B[!is.na(get("phase_casette")) & get("phase_casette") > 0 & 
            !is.na(get("upstr_seq")), 
        c("casette_seq_extended") := paste0(
            substr(get("upstr_seq"), nchar(get("upstr_seq")) + 1 - get("phase_casette"), 
                nchar(get("upstr_seq"))
            ),
            get("casette_seq_extended")
        )
    ]
    Casette.B[nchar(get("casette_seq_extended")) %% 3 > 0 & !is.na(get("Downstr_seq")), 
        c("casette_seq_extended") := paste0(get("casette_seq_extended"),
            substr(get("Downstr_seq"), 1, 3 - (nchar(get("casette_seq_extended")) %% 3))
        )
    ]
################################################################################    
# Translate:
    seq = Casette.B$casette_seq_extended[
        !is.na(Casette.B$casette_seq_extended)]
    # trim out-of-phase to be tidy:
    seq = substr(seq, 1, nchar(seq) - (nchar(seq) %% 3))
    prot = Biostrings::translate(as(seq, "DNAStringSet"))
    Casette.B[!is.na(get("casette_seq_extended")), c("AA_seq") := as.character(prot)]
    AS_Table.Extended[get("EventType") != "SE", c("AA_casette.B") := Casette.B$AA_seq]

    AS_Table.Extended[, c("AA_full.A") := ""]
    AS_Table.Extended[!is.na(get("AA_upstr.A")), 
        c("AA_full.A") := paste0(get("AA_full.A"), get("AA_upstr.A"))]
    AS_Table.Extended[!is.na(get("AA_casette.A")), 
        c("AA_full.A") := paste0(get("AA_full.A"), get("AA_casette.A"))]
    AS_Table.Extended[!is.na(get("AA_downstr_A")), 
        c("AA_full.A") := paste0(get("AA_full.A"), get("AA_downstr_A"))]
    AS_Table.Extended[, c("AA_full.B") := ""]
    AS_Table.Extended[!is.na(get("AA_upstr.B")), 
        c("AA_full.B") := paste0(get("AA_full.B"), get("AA_upstr.B"))]
    AS_Table.Extended[!is.na(get("AA_casette.B")), 
        c("AA_full.B") := paste0(get("AA_full.B"), get("AA_casette.B"))]
    AS_Table.Extended[!is.na(get("AA_downstr_B")), 
        c("AA_full.B") := paste0(get("AA_full.B"), get("AA_downstr_B"))]
    
    write.fst(as.data.frame(AS_Table.Extended), 
        file.path(reference_path,"fst","Splice.Extended.fst"))

    message("done\n")
}

# FetchAH_FTP <- function(ah_record, reference_path, localHub = FALSE, ah = AnnotationHub(localHub = localHub)) {
  # ah_record = ah[names(ah) == ah_record]
  
  # Best to fetch from URL
  # if(!dir.exists(file.path(reference_path, "resource"))) dir.create(file.path(reference_path, "resource"))

  # transcripts.gtf = file.path(normalizePath(reference_path), "resource", "transcripts.gtf")       
  # if(!file.exists(transcripts.gtf)) {
      # url = ah_record$sourceurl
      # assert_that(substr(url,1,3) == "ftp",
        # msg = paste("ftp site not found for", ah_record))
      # urlfile = basename(url)
      # if(substr(urlfile, nchar(urlfile) -6, nchar(urlfile)) == ".gtf.gz") {
        # download.file(url, destfile = paste(transcripts.gtf, "gz", sep="."))
        # GEOquery::gunzip(paste(transcripts.gtf, "gz", sep="."))
        # transcripts.gtf = paste0(transcripts.gtf, ".gz")
      # } else if(substr(urlfile, nchar(urlfile) - 3, nchar(urlfile)) == ".gtf") {
        # download.file(url, destfile = transcripts.gtf)
      # } else {
        # warning("sourceurl entry for AnnotationHub resource is not a valid gtf.gz or gtf file")
      # }
  # }
  # rtracklayer::import(transcripts.gtf, "gtf")
# }

#' Fetch genome / transcriptome reference from AnnotationHub and writes to reference_path
#'
#' @export
GenerateMappabilityReads <- function(fasta = "genome.fa", ah_genome = "", 
    reference_path, read_len = 70, read_stride = 10, error_pos = 35,
    verbose = FALSE, localHub = FALSE, 
    ah = AnnotationHub(localHub = localHub)) {

  if(ah_genome != "") {
    assert_that(substr(ah_genome,1,2) == "AH",
        msg = paste(ah_genome, "- Given AnnotationHub reference is incorrect"))

    genome = .fetch_AH(ah_genome, ah = ah, verbose = verbose)

    if(!dir.exists(file.path(reference_path, "resource"))) {
        dir.create(file.path(reference_path, "resource"))
    }
    fasta_file = file.path(reference_path, "resource", 
        paste(ah_genome, "fa", sep="."))
        
    if(verbose) message(paste("Preparing to export as", fasta_file))
    # Write fasta to file
    genome.DNA = rtracklayer::import(genome)
    gc()
    genome = Biostrings::replaceAmbiguities(genome)
    gc()
    
    rtracklayer::export(genome, fasta_file, "fasta")
    if(verbose) message(paste("Successful export of", fasta_file))
  } else {
    assert_that(file.exists(normalizePath(fasta)),
        msg = paste("Given genome file", normalizePath(fasta), "not found"))
    fasta_file = fasta
  }

# Run map read generator:
    run_IRFinder_GenerateMapReads(normalizePath(fasta_file), 
      file.path(normalizePath(reference_path), paste("MappabilityReads", 
        ifelse(ah_genome == "", "genome", ah_genome),"fa", sep=".")), 
        read_len, read_stride, error_pos)
}

#' @export
GenerateMappabilityBED = function(BAM = "", out.bed, threshold = 4) {
  assert_that(file.exists(BAM),
    msg = paste(BAM, "BAM file does not exist"))
  assert_that(dir.exists(dirname(out.bed)),
    msg = paste(dirname(out.bed), "directory does not exist"))
    
  return(
    IRF_GenerateMappabilityRegions(normalizePath(BAM), 
        file.path(normalizePath(dirname(out.bed)), out.bed),
        threshold = threshold)
  )
}

DetermineNMD <- function(exon_list, intron_list, genome, threshold = 50) {
    # transcript_list can be a GRanges, data.frame, 
    # or data.table coerce-able to a GRanges object
    # All members of transcript must have the same 
    # transcript-id and must not completely overlap

    # Also it is presumed the first nucleotide is the 
    # beginning of the stop codon

    assert_that(is(exon_list, "GRanges") | 
        is(exon_list, "data.frame") | 
        is(exon_list, "data.table"), 
        msg = paste("exon_list must be a GRanges, data.frame,", 
            "or data.table coerce-able to a GRanges object"))

    assert_that(is(exon_list, "GRanges") || 
        all(c("seqnames", "start", "end", "strand") %in% 
            colnames(exon_list)),
        msg = paste("exon_list must be a GRanges, data.frame,",
            "or data.table coerce-able to a GRanges object"))

    assert_that(is(intron_list, "GRanges") | is(intron_list, "data.frame") | 
        is(intron_list, "data.table"), 
        msg = paste("intron_list must be a GRanges, data.frame,", 
            "or data.table coerce-able to a GRanges object"))

    assert_that(is(intron_list, "GRanges") || 
        all(c("seqnames", "start", "end", "strand") %in% colnames(intron_list)),
        msg = paste("intron_list must be a GRanges, data.frame,",
            "or data.table coerce-able to a GRanges object"))

    message("Calculating IR-NMD")

    exon.DT = as.data.table(exon_list)
    intron.DT = as.data.table(intron_list)

    exon.DT = exon.DT[, c("seqnames", "start", "end", "strand", "transcript_id")]

    exon_gr = makeGRangesFromDataFrame(as.data.frame(exon.DT))
    exon.DT[, c("seq") := as.character(getSeq(genome, exon_gr))]

    gc()

    # Easy bit: test whether spliced transcript is NMD-inducing

    exon.MLE.DT = copy(exon.DT)

    setorderv(exon.MLE.DT, "start")
    exon.MLE.DT[, c("elem_number") := data.table::rowid(transcript_id)]
    exon.MLE.DT[get("strand") == "-", c("elem_number") :=  
        max(get("elem_number")) + 1 - get("elem_number"), 
        by = "transcript_id"]
    exon.MLE.DT[, by = "transcript_id", 
        c("is_last_elem") := (get("elem_number") == max(get("elem_number")))]

    exon.MLE.DT = exon.MLE.DT[get("is_last_elem") == FALSE]

    # sort by order
    setorderv(exon.MLE.DT, c("transcript_id", "elem_number"))

    exon.MLE.DT = exon.MLE.DT[, c("transcript_id", "seq")]
    # construct sequences:
    splice = exon.MLE.DT[, lapply(.SD, paste0, collapse = ""), by = "transcript_id"]
    splice[is.na(rowSums(stringr::str_locate(get("seq"), "N"))),
        c("AA") := as.character(
            suppressWarnings(
                Biostrings::translate(as(get("seq"), "DNAStringSet"))
            )
        )]

    # Find nucleotide position of first stop codon
    splice[, c("stop_pos") := stringr::str_locate(get("AA"), "\\*")[,1] * 3 - 2]
    splice[, c("splice_len") := nchar(get("seq"))]
    splice[!is.na(AA), stop_to_EJ := splice_len - stop_pos]

  # Hard bit: test whether IR transcript is NMD-inducing

    intron.DT = intron.DT[, c("seqnames", "start", "end", "strand", 
        "transcript_id", "intron_id")]  
    final = intron.DT[, c("intron_id", "transcript_id")]

    final[splice, on = "transcript_id", 
        c("splice_stop_pos", "splice_start_to_last_EJ", "splice_stop_to_last_EJ") := 
        list(get("i.stop_pos"), get("i.splice_len"), get("i.stop_to_EJ"))]

    final[, c("splice_is_NMD") := 
        ifelse(get("splice_start_to_last_EJ") - get("splice_stop_to_last_EJ") 
            >= threshold, TRUE, FALSE)]
    final[is.na(get("splice_stop_to_last_EJ")), c("splice_is_NMD") := FALSE]
    final[is.na(get("splice_start_to_last_EJ")), c("splice_is_NMD") := NA]

    i_partition = seq(1, nrow(intron.DT), by = 10000)
    i_partition = append(i_partition, nrow(intron.DT) + 1)

    pb = txtProgressBar(max = length(i_partition) - 1, style = 3)    
    for(i in seq_len(length(i_partition) - 1)) {
        setTxtProgressBar(pb, i)
        intron.part = intron.DT[seq(i_partition[i], i_partition[i+1] - 1)]
        intron.part$type = "intron"
        # join exons with introns to determine phase of intron    
        exon.DT.skinny = exon.DT[, -("seq")]
        intron.part.upstream = as.data.table(
            rbind(
                as.data.frame(intron.part) %>% 
                    dplyr::select("transcript_id", "intron_id",
                        "seqnames", "start", "end", "strand", "type"),
                dplyr::left_join(as.data.frame(intron.part) %>% 
                    dplyr::select("transcript_id", "intron_id"), 
                    as.data.frame(exon.DT.skinny), 
                    by = "transcript_id") %>% 
                    dplyr::mutate(type = "exon")
            )
        )

        setorderv(intron.part.upstream, "start")
        intron.part.upstream[, c("elem_number") := data.table::rowid(intron_id)]
        intron.part.upstream[get("strand") == "-", 
            c("elem_number") := max(get("elem_number")) + 1 - get("elem_number"), 
            by = "intron_id"]
    
        # remove introns upstream to first available exon
        intron.part.upstream[get("type") == "exon", 
            c("first_exon_id") := min(get("elem_number")), 
            by = "intron_id"]
        intron.part.upstream[, 
            c("first_exon_id") := min(get("first_exon_id"), na.rm = TRUE),
            by = "intron_id"
        ]
        intron.part.upstream = 
            intron.part.upstream[get("type") == "exon" | 
                get("elem_number") > get("first_exon_id")]
                
        # trim exons downstream of intron
        intron.part.upstream[intron.part.upstream[get("type") == "intron"], 
            on = "intron_id", c("intron_pos") := get("i.elem_number")]    

        intron.part.upstream = intron.part.upstream[!is.na(get("intron_pos"))]
        intron.part.upstream = 
            intron.part.upstream[get("elem_number") < get("intron_pos") | 
                get("type") == "intron" ]
    
    # Retrieve first 1000 bases of intron sequence. Most introns may be screened using this method. Save overhead
    
        intron.part.short = intron.part.upstream[get("type") == "intron"]
        intron.part.short[ 
            get("strand") == "+" & get("end") - get("start") > 1000, 
            c("end") := get("start") + 1000 ]
        intron.part.short[ 
            get("strand") == "-" & get("end") - get("start") > 1000, 
            c("start") := get("end") - 1000 ]
        
        intron.short_gr = makeGRangesFromDataFrame(as.data.frame(intron.part.short))
        intron.part.short[, c("seq") := as.character(getSeq(genome, intron.short_gr))]    
        intron.part.upstream[exon.DT, 
            on = c("transcript_id", "seqnames", "start", "end", "strand"), 
            c("seq") := get("i.seq")]
        intron.part.upstream[intron.part.short, 
            on = c("intron_id", "type"), 
            c("seq") := get("i.seq")]

        # Test introns by translation
        setorder(intron.part.upstream, transcript_id, elem_number)
        intron.part.upstream = intron.part.upstream[, c("intron_id", "seq")]

        IRT = intron.part.upstream[, lapply(.SD, paste0, collapse = ""), by = "intron_id"]
        IRT[is.na(rowSums(stringr::str_locate(get("seq"), "N"))),
         c("AA") := as.character(
            suppressWarnings(
                Biostrings::translate(as(get("seq"), "DNAStringSet"))
            )
        )]
        
    # Find nucleotide position of first stop codon
        IRT[, c("stop_pos") := stringr::str_locate(get("AA"), "\\*")[,1] * 3 - 2]
        IRT[, c("IRT_len") := nchar(get("seq"))]
        IRT[!is.na(get("AA")), c("stop_to_EJ") := get("IRT_len") - get("stop_pos")]
        IRT[, c("use_short") := TRUE]
        
        IRT[, c("IRT_is_NMD") := ifelse(get("stop_to_EJ") >= get("threshold"), TRUE, FALSE)]
        IRT[is.na(get("stop_pos")), c("IRT_is_NMD") := FALSE]
        IRT[is.na(get("IRT_len")), c("IRT_is_NMD") := NA]
        
    # Annotate into final
        final[IRT, on = "intron_id", 
            c("IRT_stop_pos", "IRT_start_to_last_EJ", "IRT_stop_to_last_EJ", 
                "IRT_use_short", "IRT_is_NMD") := 
            list(get("i.stop_pos"), get("i.IRT_len"), get("i.stop_to_EJ"), 
                get("i.use_short"), get("i.IRT_is_NMD"))]
    
    # Now exclude NMD-TRUE introns from full analysis
    
        intron.part = intron.part[!(get("intron_id") %in% 
            IRT$intron_id[IRT$IRT_is_NMD == TRUE])]

        # Exclude introns preceding any ORF exons:
        intron.part = intron.part[get("intron_id") %in% IRT$intron_id]

        intron_gr = makeGRangesFromDataFrame(as.data.frame(intron.part))
        intron.part[, c("seq") := as.character(getSeq(genome, intron_gr))]

        intron.MLE.DT = as.data.table(
            rbind(
                as.data.frame(intron.part) %>% 
                    dplyr::select("transcript_id", "intron_id",
                        "seqnames", "start", "end", "strand", "seq"),
                dplyr::left_join(as.data.frame(intron.part) %>% 
                    dplyr::select("transcript_id", "intron_id"), 
                    as.data.frame(exon.DT), 
                    by = "transcript_id")
            )
        )

    # sort
        setorderv(intron.MLE.DT, "start")
        intron.MLE.DT[, c("elem_number") := data.table::rowid(get("transcript_id"))]
        intron.MLE.DT[get("strand") == "-", 
            c("elem_number") := max(get("elem_number")) + 1 - get("elem_number"), 
            by = "transcript_id"]
        intron.MLE.DT[, by = "transcript_id", 
            c("is_last_elem") := (get("elem_number") == max(get("elem_number")))]

        intron.MLE.DT = intron.MLE.DT[get("is_last_elem") == FALSE]
    
    # sort by order
        setorderv(intron.MLE.DT, c("transcript_id", "elem_number"))

        intron.MLE.DT = intron.MLE.DT[, c("intron_id", "seq")]

        IRT = intron.MLE.DT[, lapply(.SD, paste0, collapse = ""), by = "intron_id"]
        IRT[is.na(rowSums(stringr::str_locate(get("seq"), "N"))),
            c("AA") := as.character(
                suppressWarnings(
                    Biostrings::translate(as(get("seq"), "DNAStringSet"))
                )
            )]
    
    # Find nucleotide position of first stop codon
        IRT[, c("stop_pos") := stringr::str_locate(get("AA"), "\\*")[,1] * 3 - 2]
        IRT[, c("IRT_len") := nchar(get("seq"))]
        IRT[!is.na(get("AA")), c("stop_to_EJ") := get("IRT_len") - get("stop_pos")]
        IRT[, c("use_short") := FALSE]
        
        IRT[, c("IRT_is_NMD") := ifelse(get("stop_to_EJ") >= threshold, TRUE, FALSE)]
        IRT[is.na(stop_pos), c("IRT_is_NMD") := FALSE]
        IRT[is.na(IRT_len), c("IRT_is_NMD") := NA]
    
        final[IRT, on = "intron_id", 
            c("IRT_stop_pos", "IRT_start_to_last_EJ", "IRT_stop_to_last_EJ", 
                "IRT_use_short", "IRT_is_NMD") := 
            list(get("i.stop_pos"), get("i.IRT_len"), get("i.stop_to_EJ"), 
                get("i.use_short"), get("i.IRT_is_NMD"))
        ]
        gc()
    }
    setTxtProgressBar(pb,i)
    close(pb)
    
    message("done\n")
    return(final)
}







